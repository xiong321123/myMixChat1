import nano from 'nano-seconds';
import forge from 'node-forge';
import { Uint64LE } from 'int64-buffer';
import { parse, stringify, v4, validate } from 'uuid';
import BigNumber from 'bignumber.js';
import { x25519, edwardsToMontgomery, edwardsToMontgomeryPriv, ed25519 } from '@noble/curves/ed25519';
import { Field } from '@noble/curves/abstract/modular';
import { bytesToNumberLE, numberToBytesLE } from '@noble/curves/abstract/utils';
import { blake3 } from '@noble/hashes/blake3';
import { sha3_256 } from '@noble/hashes/sha3';
import { sha256 } from '@noble/hashes/sha256';
import { sha512 } from '@noble/hashes/sha512';
import axios from 'axios';
import axiosRetry, { isIdempotentRequestError } from 'axios-retry';
import isRetryAllowed from 'is-retry-allowed';
import serialize from 'serialize-javascript';
import WebSocket from 'ws';
import bs58 from 'bs58';
import qs from 'qs';
import { ungzip, gzip } from 'pako';
import merge from 'lodash.merge';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }
      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}

/**
 * mixin uses raw url encoding as default for base64 process
 * base64RawURLEncode is the standard raw, unpadded base64 encoding
 * base64RawURLDecode is same as encode
 * like Golang version https://pkg.go.dev/encoding/base64#Encoding
 */
var base64RawURLEncode = function base64RawURLEncode(raw) {
  var buf = raw;
  if (typeof raw === 'string') {
    buf = Buffer.from(raw);
  } else if (raw instanceof Uint8Array) {
    buf = Buffer.from(raw);
  }
  if (buf.length === 0) {
    return '';
  }
  return buf.toString('base64').replaceAll('=', '').replaceAll('+', '-').replaceAll('/', '_');
};
var base64RawURLDecode = function base64RawURLDecode(raw) {
  var data = raw instanceof Buffer ? raw.toString() : raw;
  data = data.replaceAll('-', '+').replaceAll('_', '/');
  return Buffer.from(data, 'base64');
};

var zeros = '0';
while (zeros.length < 256) {
  zeros += zeros;
}
var getMultiplier = function getMultiplier(n) {
  return BigNumber("1" + zeros.substring(0, n));
};
var formatUnits = function formatUnits(amount, unit) {
  var m = getMultiplier(unit);
  return BigNumber(amount).dividedBy(m);
};
var parseUnits = function parseUnits(amount, unit) {
  var m = getMultiplier(unit);
  return BigNumber(amount).times(m);
};

var MaximumEncodingInt = 0xffff;
var AggregatedSignaturePrefix = 0xff01;
var magic = /*#__PURE__*/Buffer.from([0x77, 0x77]);
var empty = /*#__PURE__*/Buffer.from([0x00, 0x00]);
var integerToBytes = function integerToBytes(x) {
  var bytes = [];
  var i = x;
  do {
    bytes.unshift(i & 255);
    i = i / Math.pow(2, 8) | 0;
  } while (i !== 0);
  return bytes;
};
var bigNumberToBytes = function bigNumberToBytes(x) {
  var bytes = [];
  var i = x;
  do {
    bytes.unshift(i.mod(256).toNumber());
    i = i.dividedToIntegerBy(256);
  } while (!i.isZero());
  return Buffer.from(bytes);
};
var putUvarInt = function putUvarInt(x) {
  var buf = [];
  var i = 0;
  while (x >= 0x80) {
    buf[i] = x | 0x80;
    x >>= 7;
    i++;
  }
  buf[i] = x;
  return buf;
};
var Encoder = /*#__PURE__*/function () {
  function Encoder(buf) {
    this.buf = Buffer.from('');
    if (buf) {
      this.buf = buf;
    }
  }
  var _proto = Encoder.prototype;
  _proto.hex = function hex() {
    return this.buf.toString('hex');
  };
  _proto.write = function write(buf) {
    this.buf = Buffer.concat([this.buf, buf]);
  };
  _proto.writeBytes = function writeBytes(buf) {
    var len = buf.byteLength;
    this.writeInt(len);
    this.write(buf);
  };
  _proto.writeSlice = function writeSlice(buf) {
    var l = buf.length;
    if (l > 128) throw new Error("slice too long, length " + l + ", maximum 128");
    this.write(Buffer.from([l]));
    this.write(buf);
  };
  _proto.writeInt = function writeInt(i) {
    if (i > MaximumEncodingInt) {
      throw new Error("invalid integer " + i + ", maximum " + MaximumEncodingInt);
    }
    var buf = Buffer.alloc(2);
    buf.writeUInt16BE(i);
    this.write(buf);
  };
  _proto.writeUint16 = function writeUint16(i) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16BE(i);
    this.write(buf);
  };
  _proto.writeUint32 = function writeUint32(i) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32BE(i);
    this.write(buf);
  };
  _proto.writeUint64 = function writeUint64(i) {
    var buf = Buffer.alloc(8);
    buf.writeBigUInt64BE(i);
    this.write(buf);
  };
  _proto.writeInteger = function writeInteger(i) {
    var b = bigNumberToBytes(i);
    this.writeInt(b.byteLength);
    this.write(b);
  }
  // TODO convert array like to array
  ;
  _proto.writeUUID = function writeUUID(id) {
    var uuid = parse(id);
    for (var i = 0; i < uuid.length; i += 1) {
      this.write(Buffer.from([uuid[i]]));
    }
  };
  _proto.encodeInput = function encodeInput(input) {
    var i = input;
    this.write(Buffer.from(i.hash, 'hex'));
    this.writeInt(i.index);
    if (!i.genesis) i.genesis = '';
    this.writeInt(i.genesis.length);
    this.write(Buffer.from(i.genesis));
    var d = i.deposit;
    if (typeof d === 'undefined') {
      this.write(empty);
    } else {
      // TODO... to test...
      this.write(magic);
      this.write(Buffer.from(d.chain, 'hex'));
      var asset = Buffer.from(d.asset);
      this.writeInt(asset.byteLength);
      this.write(asset);
      var tx = Buffer.from(d.transaction);
      this.writeInt(tx.byteLength);
      this.write(tx);
      this.writeUint64(d.index);
      this.writeInteger(parseUnits(Number(d.amount).toFixed(8), 8));
    }
    var m = i.mint;
    if (typeof m === 'undefined') {
      this.write(empty);
    } else {
      this.write(magic);
      if (!m.group) m.group = '';
      this.writeInt(m.group.length);
      this.write(Buffer.from(m.group));
      this.writeUint64(m.batch);
      this.writeInteger(parseUnits(Number(m.amount).toFixed(8), 8));
    }
  };
  _proto.encodeOutput = function encodeOutput(output) {
    var _this = this;
    var o = output;
    if (!o.type) o.type = 0;
    this.write(Buffer.from([0x00, o.type]));
    this.writeInteger(parseUnits(Number(o.amount).toFixed(8), 8));
    this.writeInt(o.keys.length);
    o.keys.forEach(function (k) {
      return _this.write(Buffer.from(k, 'hex'));
    });
    this.write(o.mask ? Buffer.from(o.mask, 'hex') : Buffer.alloc(32, 0));
    if (!o.script) o.script = '';
    var s = Buffer.from(o.script, 'hex');
    this.writeInt(s.byteLength);
    this.write(s);
    var w = o.withdrawal;
    if (!w) {
      this.write(empty);
    } else {
      this.write(magic);
      var addr = Buffer.from(w.address);
      this.writeInt(addr.byteLength);
      this.write(addr);
      var tag = Buffer.from(w.tag);
      this.writeInt(tag.byteLength);
      this.write(tag);
    }
  };
  _proto.encodeAggregatedSignature = function encodeAggregatedSignature(js) {
    var _this2 = this;
    this.writeInt(MaximumEncodingInt);
    this.writeInt(AggregatedSignaturePrefix);
    this.write(Buffer.from(js.signature, 'hex'));
    if (js.signers.length === 0) {
      this.write(Buffer.from([0x00]));
      this.writeInt(0);
      return;
    }
    js.signers.forEach(function (m, i) {
      if (i > 0 && m <= js.signers[i - 1]) {
        throw new Error('signers not sorted');
      }
      if (m > MaximumEncodingInt) {
        throw new Error('signer overflow');
      }
    });
    var max = js.signers[js.signers.length - 1];
    if (((max / 8 | 0) + 1 | 0) > js.signature.length * 2) {
      // TODO... not check...
      this.write(Buffer.from([0x01]));
      this.writeInt(js.signature.length);
      js.signers.forEach(function (m) {
        return _this2.writeInt(m);
      });
      return;
    }
    var masks = Buffer.alloc((max / 8 | 0) + 1 | 0);
    js.signers.forEach(function (m) {
      masks[m / 8 | 0] ^= 1 << (m % 8 | 0);
    });
    this.write(Buffer.from([0x00]));
    this.writeInt(masks.length);
    this.write(masks);
  };
  _proto.encodeSignature = function encodeSignature(sm) {
    var _this3 = this;
    var ss = Object.entries(sm).map(function (_ref) {
      var k = _ref[0],
        v = _ref[1];
      return {
        index: k,
        sig: v
      };
    }).sort(function (a, b) {
      return Number(a.index) - Number(b.index);
    });
    this.writeInt(ss.length);
    ss.forEach(function (s) {
      _this3.writeUint16(Number(s.index));
      _this3.write(Buffer.from(s.sig, 'hex'));
    });
  };
  return Encoder;
}();

/** Supporting multisig for tokens & collectibles */
var hashMembers = function hashMembers(ids) {
  var key = ids.sort().join('');
  return newHash(Buffer.from(key)).toString('hex');
};
/** Generate an unique conversation id for contact */
var uniqueConversationID = function uniqueConversationID(userID, recipientID) {
  var _sort = [userID, recipientID].sort(),
    minId = _sort[0],
    maxId = _sort[1];
  var md5 = forge.md.md5.create();
  md5.update(minId);
  md5.update(maxId);
  var bytes = Buffer.from(md5.digest().bytes(), 'binary');
  bytes[6] = bytes[6] & 0x0f | 0x30;
  bytes[8] = bytes[8] & 0x3f | 0x80;
  return stringify(bytes);
};
var newHash = function newHash(data) {
  return Buffer.from(sha3_256.create().update(data).digest());
};
var sha256Hash = function sha256Hash(data) {
  return Buffer.from(sha256.create().update(data).digest());
};
var sha512Hash = function sha512Hash(data) {
  return Buffer.from(sha512.create().update(data).digest());
};
var blake3Hash = function blake3Hash(data) {
  return Buffer.from(blake3.create({}).update(data).digest());
};
var getUuid = function getUuid() {
  return v4();
};

var scMinusOne = /*#__PURE__*/Buffer.from('ecd3f55c1a631258d69cf7a2def9de1400000000000000000000000000000010', 'hex');
var base = /*#__PURE__*/ed25519.ExtendedPoint.fromHex('5866666666666666666666666666666666666666666666666666666666666666');
var fn = /*#__PURE__*/Field(ed25519.CURVE.n, undefined, true);
var isReduced = function isReduced(x) {
  for (var i = x.byteLength - 1; i >= 0; i--) {
    if (x.at(i) > scMinusOne.at(i)) return false;
    if (x.at(i) < scMinusOne.at(i)) return true;
  }
  return true;
};
var setBytesWithClamping = function setBytesWithClamping(x) {
  if (x.byteLength !== 32) throw new Error('edwards25519: invalid SetBytesWithClamping input length');
  var wideBytes = Buffer.alloc(64);
  x.copy(wideBytes, 0, 0, 32);
  wideBytes[0] &= 248;
  wideBytes[31] &= 63;
  wideBytes[31] |= 64;
  var m = fn.create(bytesToNumberLE(wideBytes.subarray(0, 32)));
  return m;
};
var setUniformBytes = function setUniformBytes(x) {
  if (x.byteLength !== 64) throw new Error('edwards25519: invalid setUniformBytes input length');
  var wideBytes = Buffer.alloc(64);
  x.copy(wideBytes);
  var m = fn.create(bytesToNumberLE(wideBytes));
  return m;
};
var setCanonicalBytes = function setCanonicalBytes(x) {
  if (x.byteLength !== 32) throw new Error('invalid scalar length');
  if (!isReduced(x)) throw new Error('invalid scalar encoding');
  var s = fn.create(bytesToNumberLE(x));
  return s;
};
var scalarBaseMult = function scalarBaseMult(x) {
  var res = base.multiply(x);
  // @ts-ignore
  return Buffer.from(res.toRawBytes());
};
var scalarBaseMultToPoint = function scalarBaseMultToPoint(x) {
  return base.multiply(x);
};
var publicFromPrivate = function publicFromPrivate(priv) {
  var x = setCanonicalBytes(priv);
  var v = scalarBaseMult(x);
  return v;
};
var sign = function sign(msg, key) {
  var digest1 = sha512Hash(key.subarray(0, 32));
  var messageDigest = sha512Hash(Buffer.concat([digest1.subarray(32), msg]));
  var z = setUniformBytes(messageDigest);
  var r = scalarBaseMult(z);
  var pub = publicFromPrivate(key);
  var hramDigest = sha512Hash(Buffer.concat([r, pub, msg]));
  var x = setUniformBytes(hramDigest);
  var y = setCanonicalBytes(key);
  var s = numberToBytesLE(fn.add(fn.mul(x, y), z), 32);
  return Buffer.concat([r, s]);
};
var newPoint = function newPoint(x) {
  return ed25519.ExtendedPoint.fromHex(x.toString('hex'));
};
var keyMultPubPriv = function keyMultPubPriv(pub, priv) {
  var q = newPoint(pub);
  var x = setCanonicalBytes(priv);
  var res = q.multiply(x);
  // @ts-ignore
  return Buffer.from(res.toRawBytes());
};
var hashScalar = function hashScalar(k, index) {
  var tmp = Buffer.from(putUvarInt(index));
  var src = Buffer.alloc(64);
  var hash = blake3Hash(Buffer.concat([k, tmp]));
  hash.copy(src, 0, 0, 32);
  hash = blake3Hash(hash);
  hash.copy(src, 32, 0, 32);
  var s = setUniformBytes(src);
  hash = blake3Hash(Buffer.from(numberToBytesLE(s, 32)));
  hash.copy(src, 0, 0, 32);
  hash = blake3Hash(hash);
  hash.copy(src, 32, 0, 32);
  return setUniformBytes(src);
};
var edwards25519 = {
  scalar: fn,
  x25519: x25519,
  edwardsToMontgomery: edwardsToMontgomery,
  edwardsToMontgomeryPriv: edwardsToMontgomeryPriv,
  setBytesWithClamping: setBytesWithClamping,
  setCanonicalBytes: setCanonicalBytes,
  setUniformBytes: setUniformBytes,
  isReduced: isReduced,
  publicFromPrivate: publicFromPrivate,
  scalarBaseMult: scalarBaseMult,
  scalarBaseMultToPoint: scalarBaseMultToPoint,
  sign: sign,
  newPoint: newPoint,
  keyMultPubPriv: keyMultPubPriv,
  hashScalar: hashScalar
};

// @ts-ignore
var getNanoTime = function getNanoTime() {
  var now = nano.now();
  return now[0] * 1e9 + now[1];
};
var sharedEd25519Key = function sharedEd25519Key(keystore) {
  var pub = 'server_public_key' in keystore ? edwards25519.edwardsToMontgomery(Buffer.from(keystore.server_public_key, 'hex')) : base64RawURLDecode(keystore.pin_token_base64);
  var pri = edwards25519.edwardsToMontgomeryPriv(Buffer.from(keystore.session_private_key, 'hex'));
  return edwards25519.x25519.getSharedSecret(pri, pub);
};
var getTipPinUpdateMsg = function getTipPinUpdateMsg(pub, counter) {
  var enc = new Encoder(pub);
  enc.writeUint64(BigInt(counter));
  return enc.buf;
};
var signEd25519PIN = function signEd25519PIN(pin, keystore) {
  if (!keystore || !keystore.session_private_key) return '';
  if (!('server_public_key' in keystore) && !('pin_token_base64' in keystore)) return '';
  var blockSize = 16;
  var _pin = Buffer.from(pin, 'hex');
  var iterator = Buffer.from(new Uint64LE(getNanoTime()).toBuffer());
  var time = Buffer.from(new Uint64LE(Date.now() / 1000).toBuffer());
  var buf = Buffer.concat([_pin, time, iterator]);
  var buffer = forge.util.createBuffer(buf.toString('binary'));
  var paddingLen = blockSize - buffer.length() % blockSize;
  var paddings = [];
  for (var i = 0; i < paddingLen; i += 1) {
    paddings.push(paddingLen);
  }
  buffer.putBytes(Buffer.from(paddings).toString('binary'));
  var iv = forge.random.getBytesSync(blockSize);
  var sharedKey = sharedEd25519Key(keystore);
  var cipher = forge.cipher.createCipher('AES-CBC', forge.util.createBuffer(sharedKey, 'raw'));
  cipher.start({
    iv: iv
  });
  cipher.update(buffer);
  cipher.finish();
  var pinBuff = forge.util.createBuffer();
  pinBuff.putBytes(iv);
  pinBuff.putBytes(cipher.output.getBytes());
  var len = pinBuff.length();
  var encryptedBytes = Buffer.from(pinBuff.getBytes(len - 16), 'binary');
  return base64RawURLEncode(encryptedBytes);
};
var getCreateAddressTipBody = function getCreateAddressTipBody(asset_id, publicKey, tag, name) {
  var msg = "TIP:ADDRESS:ADD:" + (asset_id + publicKey + tag + name);
  return sha256Hash(Buffer.from(msg));
};
var getRemoveAddressTipBody = function getRemoveAddressTipBody(address_id) {
  var msg = "TIP:ADDRESS:REMOVE:" + address_id;
  return sha256Hash(Buffer.from(msg));
};
var getVerifyPinTipBody = function getVerifyPinTipBody(timestamp) {
  var msg = "TIP:VERIFY:" + ("" + timestamp).padStart(32, '0');
  return Buffer.from(msg);
};
var signTipBody = function signTipBody(pin, msg) {
  var privateKey = Buffer.from(pin, 'hex');
  var signData = forge.pki.ed25519.sign({
    message: msg,
    privateKey: privateKey
  });
  return signData.toString('hex');
};

var ResponseError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(ResponseError, _Error);
  function ResponseError(code, description, status, extra, requestId, originalError) {
    var _this;
    _this = _Error.call(this, "code: " + code + ", description: " + description + ", status: " + status + ", extra: " + extra + ", requestId: " + requestId + " originalError: " + originalError) || this;
    _this.code = code;
    _this.description = description;
    _this.status = status;
    _this.extra = extra;
    _this.requestId = requestId;
    _this.originalError = originalError;
    return _this;
  }
  return ResponseError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var getED25519KeyPair = function getED25519KeyPair() {
  var seed = Buffer.from(forge.random.getBytesSync(32), 'binary');
  var keypair = forge.pki.ed25519.generateKeyPair({
    seed: seed
  });
  return {
    privateKey: Buffer.from(keypair.privateKey),
    publicKey: Buffer.from(keypair.publicKey),
    seed: seed
  };
};
var signToken = function signToken(payload, private_key) {
  var header = base64RawURLEncode(serialize({
    alg: 'EdDSA',
    typ: 'JWT'
  }));
  var payloadStr = base64RawURLEncode(serialize(payload));
  var privateKey = Buffer.from(private_key, 'hex');
  var result = [header, payloadStr];
  var signData = forge.pki.ed25519.sign({
    message: result.join('.'),
    encoding: 'utf8',
    privateKey: privateKey
  });
  var sign = base64RawURLEncode(signData);
  result.push(sign);
  return result.join('.');
};
/**
 * sign an authentication token
 * sig: sha256(method + uri + params)
 */
var signAuthenticationToken = function signAuthenticationToken(methodRaw, uri, params, requestID, keystore) {
  if (!keystore.session_id || !validate(keystore.session_id)) return '';
  var method = 'GET';
  if (methodRaw) method = methodRaw.toLocaleUpperCase();
  var data = '';
  if (typeof params === 'object') {
    data = serialize(params, {
      unsafe: true
    });
  } else if (typeof params === 'string') {
    data = params;
  }
  var iat = Math.floor(Date.now() / 1000);
  var exp = iat + 3600;
  var md = forge.md.sha256.create();
  md.update(method + uri + data, 'utf8');
  var payload = {
    uid: keystore.app_id,
    sid: keystore.session_id,
    iat: iat,
    exp: exp,
    jti: requestID,
    sig: md.digest().toHex(),
    scp: 'FULL'
  };
  return signToken(payload, keystore.session_private_key);
};
/**
 * Sign an OAuth access token
 * Notes:
 * requestID should equal the one in header
 * scope should be oauth returned
 */
var signOauthAccessToken = function signOauthAccessToken(methodRaw, uri, params, requestID, keystore) {
  if (!keystore.scope) return '';
  var method = 'GET';
  if (methodRaw) method = methodRaw.toLocaleUpperCase();
  var data = '';
  if (typeof params === 'object') {
    data = serialize(params, {
      unsafe: true
    });
  } else if (typeof params === 'string') {
    data = params;
  }
  var iat = Math.floor(Date.now() / 1000);
  var exp = iat + 3600;
  var md = forge.md.sha256.create();
  md.update(method + uri + data, 'utf8');
  var payload = {
    iss: keystore.app_id,
    aid: keystore.authorization_id,
    iat: iat,
    exp: exp,
    jti: requestID,
    sig: md.digest().toHex(),
    scp: keystore.scope
  };
  return signToken(payload, keystore.session_private_key);
};
var signAccessToken = function signAccessToken(methodRaw, uri, params, requestID, keystore) {
  if (!keystore || !keystore.app_id || !keystore.session_private_key) return '';
  if (!validate(keystore.app_id)) return '';
  var privateKey = Buffer.from(keystore.session_private_key, 'hex');
  if (privateKey.byteLength !== 32) return '';
  if ('authorization_id' in keystore) {
    return signOauthAccessToken(methodRaw, uri, params, requestID, keystore);
  }
  return signAuthenticationToken(methodRaw, uri, params, requestID, keystore);
};

var hostURL = ['https://api.mixin.one', 'https://mixin-api.zeromesh.net'];
axios.defaults.headers.post['Content-Type'] = 'application/json';
axios.defaults.headers.put['Content-Type'] = 'application/json';
axios.defaults.headers.patch['Content-Type'] = 'application/json';
function http(keystore, config) {
  var timeout = (config == null ? void 0 : config.timeout) || 3000;
  var retries = (config == null ? void 0 : config.retry) || 5;
  var ins = axios.create(_extends({
    baseURL: hostURL[0],
    timeout: timeout
  }, config));
  ins.interceptors.request.use(function (config) {
    var _config$baseURL;
    var method = config.method,
      data = config.data;
    var url = axios.getUri(config).slice((_config$baseURL = config.baseURL) == null ? void 0 : _config$baseURL.length);
    if (config.headers) {
      var requestID = v4();
      config.headers['X-Request-Id'] = requestID;
      var jwtToken = signAccessToken(method, url, data, requestID, keystore);
      config.headers.Authorization = "Bearer " + jwtToken;
    }
    return config;
  });
  ins.interceptors.response.use( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(res) {
      var _res$data, data, error;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _res$data = res.data, data = _res$data.data, error = _res$data.error;
              if (!error) {
                _context.next = 3;
                break;
              }
              throw new ResponseError(error.code, error.description, error.status, error.extra, res.headers['x-request-id'], error);
            case 3:
              return _context.abrupt("return", data);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
  ins.interceptors.response.use(undefined, /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return config == null ? void 0 : config.responseCallback == null ? void 0 : config.responseCallback(e);
            case 2:
              return _context2.abrupt("return", Promise.reject(e));
            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }());
  axiosRetry(ins, {
    retries: retries,
    shouldResetTimeout: true,
    retryDelay: function retryDelay() {
      return 500;
    },
    retryCondition: function retryCondition(error) {
      return !error.response && Boolean(error.code) &&
      // Prevents retrying cancelled requests
      isRetryAllowed(error) || isIdempotentRequestError(error);
    },
    onRetry: function onRetry(_count, err, requestConfig) {
      var _err$config, _err$config2;
      if (config != null && config.baseURL) return;
      requestConfig.baseURL = ((_err$config = err.config) == null ? void 0 : _err$config.baseURL) === hostURL[0] ? hostURL[1] : hostURL[0];
      ins.defaults.baseURL = ((_err$config2 = err.config) == null ? void 0 : _err$config2.baseURL) === hostURL[0] ? hostURL[1] : hostURL[0];
    }
  });
  return ins;
}
var mixinRequest = /*#__PURE__*/http();

var createAxiosClient = function createAxiosClient(keystore, requestConfig) {
  return http(keystore, requestConfig);
};
var createRequestClient = function createRequestClient(axiosInstance) {
  return {
    request: function request(config) {
      return axiosInstance.request(config);
    }
  };
};
var buildClient = function buildClient(KeystoreClient) {
  return function (config) {
    if (config === void 0) {
      config = {};
    }
    if (!KeystoreClient) throw new Error('keystore client is required');
    var _config = config,
      keystore = _config.keystore,
      requestConfig = _config.requestConfig;
    var axiosInstance = createAxiosClient(keystore, requestConfig);
    var requestClient = createRequestClient(axiosInstance);
    var keystoreClient = KeystoreClient(axiosInstance, keystore);
    return Object.assign(keystoreClient, requestClient);
  };
};

/**
 * All tokens withdrawal needs an address
 * Should create an address first, the address can be deleted, can't be updated.
 * If the address belongs to another mixin user, the withdrawal fee will be free.
 * tag or memo can be blank.
 * Detail: https://developers.mixin.one/docs/api/withdrawal/address-add
 */
var AddressKeystoreClient = function AddressKeystoreClient(axiosInstance, keystore) {
  return {
    /** Get an address by addressID */
    fetch: function fetch(addressID) {
      return axiosInstance.get("/addresses/" + addressID);
    },
    /** Get a list of withdrawal addresses for the given asset */
    fetchList: function fetchList(assetID) {
      return axiosInstance.get("/assets/" + assetID + "/addresses");
    },
    /** Create a new withdrawal address */
    create: function create(pin, params) {
      var _params$tag;
      var msg = getCreateAddressTipBody(params.asset_id, params.destination, (_params$tag = params.tag) != null ? _params$tag : '', params.label);
      var signedTipPin = signTipBody(pin, msg);
      var encrypted = signEd25519PIN(signedTipPin, keystore);
      return axiosInstance.post('/addresses', _extends({}, params, {
        pin: encrypted
      }));
    },
    /** Delete a specified address by addressID */
    "delete": function _delete(pin, addressID) {
      var msg = getRemoveAddressTipBody(addressID);
      var signedTipPin = signTipBody(pin, msg);
      var encrypted = signEd25519PIN(signedTipPin, keystore);
      return axiosInstance.post("/addresses/" + addressID + "/delete", {
        pin: encrypted
      });
    }
  };
};
var AddressClient = /*#__PURE__*/buildClient(AddressKeystoreClient);

// TODO add app api for developer document
/**
 * API for mixin users and official app
 * Notes:
 * * Some api only available for mixin official app
 * * Each Mixin user can only create two free apps
 * https://developers.mixin.one/
 */
var AppKeystoreClient = function AppKeystoreClient(axiosInstance) {
  return {
    /** Get information of current user's a specific app */
    fetch: function fetch(appID) {
      return axiosInstance.get("/apps/" + appID);
    },
    /**
     * Get app list of current user
     * Available for mixin official developer app only
     */
    fetchList: function fetchList() {
      return axiosInstance.get("/apps");
    },
    /**
     * Get app number of current user and the price to buy new credit
     * Available for mixin official developer app only
     */
    properties: function properties() {
      return axiosInstance.get("/apps/property");
    },
    /** Get user's app share list */
    favorites: function favorites(userID) {
      return axiosInstance.get("/users/" + userID + "/apps/favorite");
    },
    /** Developer can create up to 2 free apps, or pay for more unlimited apps */
    create: function create(params) {
      return axiosInstance.post("/apps", params);
    },
    /** Update app setting */
    update: function update(appID, params) {
      return axiosInstance.post("/apps/" + appID, params);
    },
    /** Get a new app secret */
    updateSecret: function updateSecret(appID) {
      return axiosInstance.post("/apps/" + appID + "/secret");
    },
    /**
     * Get a new app session
     * @param session_public_key: public key of ed25519 session keys
     */
    updateSafeSession: function updateSafeSession(appID, data) {
      return axiosInstance.post("/safe/apps/" + appID + "/session", data);
    },
    /**
     * Register app to safe, the spend private key would be the same as the tip private key
     * @param spend_public_key: hex public key of ed25519 tip/spend keys
     * @param signature_base64: signature of the SHA256Hash of the app_id using ed25519 tip/spend private key
     */
    registerSafe: function registerSafe(appID, data) {
      return axiosInstance.post("/safe/apps/" + appID + "/register", data);
    },
    /**
     * Add to your share list
     * User can have up to 3 favorite apps
     */
    favorite: function favorite(appID) {
      return axiosInstance.post("/apps/" + appID + "/favorite");
    },
    /** Removing from your share list */
    unfavorite: function unfavorite(appID) {
      return axiosInstance.post("/apps/" + appID + "/unfavorite");
    }
  };
};
var AppClient = /*#__PURE__*/buildClient(AppKeystoreClient);

/**
 * Get personal information about asset.
 * Notes:
 * * Get /assets may not have a deposit address, if you want a deposit address,
 * * should request /assets/:asset_id first.
 * https://developers.mixin.one/docs/api/assets/assets
 */
var AssetKeystoreClient = function AssetKeystoreClient(axiosInstance) {
  return {
    /** Get the specified asset of current user, the ASSETS:READ permission is required */
    fetch: function fetch(assetID) {
      return axiosInstance.get("/assets/" + assetID);
    },
    /** Get the asset list of current user */
    fetchList: function fetchList() {
      return axiosInstance.get('/assets');
    },
    /** Get specific asset's snapshots of current user */
    snapshots: function snapshots(assetID) {
      return axiosInstance.get("/assets/" + assetID + "/snapshots");
    }
  };
};
var AssetClient = /*#__PURE__*/buildClient(AssetKeystoreClient);

var AttachmentKeystoreClient = function AttachmentKeystoreClient(axiosInstance) {
  var createAttachment = function createAttachment() {
    return axiosInstance.post("/attachments");
  };
  var uploadAttachmentTo = function uploadAttachmentTo(uploadURL, file) {
    return axios.create()({
      url: uploadURL,
      method: 'PUT',
      data: file,
      headers: {
        'x-amz-acl': 'public-read',
        'Content-Type': 'application/octet-stream'
      },
      maxContentLength: 2147483648
    });
  };
  return {
    /** Get a specific attachment by attachmentID */
    fetch: function fetch(attachmentID) {
      return axiosInstance.get("/attachments/" + attachmentID);
    },
    /** Create a new attachment before upload it */
    create: createAttachment,
    /** Upload a attachment */
    upload: function () {
      var _upload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(file) {
        var _yield$createAttachme, view_url, upload_url, attachment_id;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return createAttachment();
              case 2:
                _yield$createAttachme = _context.sent;
                view_url = _yield$createAttachme.view_url;
                upload_url = _yield$createAttachme.upload_url;
                attachment_id = _yield$createAttachme.attachment_id;
                if (upload_url) {
                  _context.next = 8;
                  break;
                }
                throw new Error('No upload URL');
              case 8:
                _context.next = 10;
                return uploadAttachmentTo(upload_url, file);
              case 10:
                return _context.abrupt("return", {
                  view_url: view_url,
                  attachment_id: attachment_id
                });
              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function upload(_x) {
        return _upload.apply(this, arguments);
      }
      return upload;
    }()
  };
};
var AttachmentClient = /*#__PURE__*/buildClient(AttachmentKeystoreClient);

var MainAddressPrefix = 'XIN';
var MixAddressPrefix = 'MIX';
var MixAddressVersion = 2;
var getPublicFromMainnetAddress = function getPublicFromMainnetAddress(address) {
  try {
    if (!address.startsWith(MainAddressPrefix)) return undefined;
    var data = bs58.decode(address.slice(3));
    if (data.length !== 68) return undefined;
    var payload = data.subarray(0, data.length - 4);
    var msg = Buffer.concat([Buffer.from(MainAddressPrefix), Buffer.from(payload)]);
    var checksum = newHash(msg);
    if (!checksum.subarray(0, 4).equals(data.subarray(64))) return undefined;
    return Buffer.from(payload);
  } catch (_unused) {
    return undefined;
  }
};
var getMainnetAddressFromPublic = function getMainnetAddressFromPublic(pubKey) {
  var msg = Buffer.concat([Buffer.from(MainAddressPrefix), pubKey]);
  var checksum = newHash(msg);
  var data = Buffer.concat([pubKey, checksum.subarray(0, 4)]);
  return "" + MainAddressPrefix + bs58.encode(data);
};
var parseMixAddress = function parseMixAddress(address) {
  try {
    if (!address.startsWith(MixAddressPrefix)) return undefined;
    var data = bs58.decode(address.slice(3));
    if (data.length < 3 + 16 + 4) {
      return undefined;
    }
    var payload = data.subarray(0, data.length - 4);
    var msg = Buffer.concat([Buffer.from(MixAddressPrefix), Buffer.from(payload)]);
    var checksum = newHash(msg);
    if (!checksum.subarray(0, 4).equals(Buffer.from(data.subarray(data.length - 4)))) return undefined;
    var version = data.at(0);
    var threshold = data.at(1);
    var total = data.at(2);
    if (version !== 2) return undefined;
    if (!threshold || !total || threshold === 0 || threshold > total || total > 64) return undefined;
    var memberData = payload.subarray(3);
    var members = [];
    if (memberData.length === total * 16) {
      for (var i = 0; i < total; i++) {
        var id = stringify(memberData, 16 * i);
        members.push(id);
      }
      return {
        members: members,
        threshold: threshold
      };
    }
    if (memberData.length === total * 64) {
      for (var _i = 0; _i < total; _i++) {
        var pub = memberData.subarray(64 * _i, 64 * (_i + 1));
        var addr = getMainnetAddressFromPublic(Buffer.from(pub));
        members.push(addr);
      }
      return {
        members: members,
        threshold: threshold
      };
    }
    return undefined;
  } catch (_unused2) {
    return undefined;
  }
};
var buildMixAddress = function buildMixAddress(ma) {
  if (ma.members.length > 255) {
    throw new Error("invalid members length: " + ma.members.length);
  }
  if (ma.threshold === 0 || ma.threshold > ma.members.length) {
    throw new Error("invalid threshold: " + ma.threshold);
  }
  var prefix = Buffer.concat([Buffer.from([MixAddressVersion]), Buffer.from([ma.threshold]), Buffer.from([ma.members.length])]);
  var type = '';
  var memberData = [];
  ma.members.forEach(function (addr) {
    if (addr.startsWith(MainAddressPrefix)) {
      if (!type) type = 'xin';
      if (type !== 'xin') throw new Error("inconsistent address type");
      var pub = getPublicFromMainnetAddress(addr);
      if (!pub) throw new Error("invalid mainnet address: " + addr);
      memberData.push(pub);
    } else {
      if (!type) type = 'uuid';
      if (type !== 'uuid') throw new Error("inconsistent address type");
      var id = parse(addr);
      if (!id) throw new Error("invalid mainnet address: " + addr);
      memberData.push(Buffer.from(Uint8Array.from(id)));
    }
  });
  var msg = Buffer.concat([Buffer.from(MixAddressPrefix), prefix].concat(memberData));
  var checksum = newHash(msg);
  var data = Buffer.concat([prefix].concat(memberData, [checksum.subarray(0, 4)]));
  return "" + MixAddressPrefix + bs58.encode(data);
};

var bytesToInterger = function bytesToInterger(b) {
  var x = 0;
  for (var i = 0; i < b.byteLength; i++) {
    var _byte = b.at(i);
    x *= 0x100;
    if (_byte) x += _byte;
  }
  return x;
};
var Decoder = /*#__PURE__*/function () {
  function Decoder(buf) {
    this.buf = buf;
  }
  var _proto = Decoder.prototype;
  _proto.subarray = function subarray(start, end) {
    return this.buf.subarray(start, end);
  };
  _proto.read = function read(offset) {
    this.buf = this.buf.subarray(offset);
  };
  _proto.readByte = function readByte() {
    var value = this.buf.readUint8();
    this.read(1);
    return value;
  };
  _proto.readBytes = function readBytes() {
    var len = this.readByte();
    var value = this.buf.subarray(0, len).toString('hex');
    this.read(len);
    return value;
  };
  _proto.readInt = function readInt() {
    var value = this.buf.readUInt16BE();
    this.read(2);
    return value;
  };
  _proto.readUint32 = function readUint32() {
    var value = this.buf.readUInt32BE();
    this.read(4);
    return value;
  };
  _proto.readUInt64 = function readUInt64() {
    var value = this.buf.readBigUInt64BE();
    this.read(8);
    return value;
  };
  _proto.readUUID = function readUUID() {
    var value = this.buf.subarray(0, 16);
    this.read(16);
    return value;
  };
  _proto.readInteger = function readInteger() {
    var len = this.readInt();
    var value = this.buf.subarray(0, len);
    this.read(len);
    return bytesToInterger(value);
  };
  _proto.decodeInput = function decodeInput() {
    var hash = this.subarray(0, 32).toString('hex');
    this.read(32);
    var index = this.readInt();
    var input = {
      hash: hash,
      index: index
    };
    var lenGenesis = this.readInt();
    if (lenGenesis > 0) {
      input.genesis = this.buf.subarray(0, lenGenesis).toString('hex');
      this.read(lenGenesis);
    }
    var depositPrefix = this.subarray(0, 2);
    this.read(2);
    if (depositPrefix.equals(magic)) {
      var chain = this.subarray(0, 32).toString('hex');
      this.read(32);
      var asset = this.readBytes();
      var transaction = this.readBytes();
      var _index = this.readUInt64();
      var amount = this.readInteger();
      input.deposit = {
        chain: chain,
        asset: asset,
        transaction: transaction,
        index: _index,
        amount: amount
      };
    }
    var mintPrefix = this.subarray(0, 2);
    this.read(2);
    if (mintPrefix.equals(magic)) {
      var group = this.readBytes();
      var batch = this.readUInt64();
      var _amount = this.readInteger();
      input.mint = {
        group: group,
        batch: batch,
        amount: _amount
      };
    }
    return input;
  };
  _proto.decodeOutput = function decodeOutput() {
    var t = this.subarray(0, 2);
    this.read(2);
    if (t.at(0) !== 0) throw new Error("invalid output type " + t.at(0));
    var type = t.at(1);
    var amount = this.readInteger();
    var lenKey = this.readInt();
    var keys = [];
    for (var i = 0; i < lenKey; i++) {
      var key = this.subarray(0, 32).toString('hex');
      this.read(32);
      keys.push(key);
    }
    var mask = this.subarray(0, 32).toString('hex');
    this.read(32);
    var lenScript = this.readInt();
    var script = this.buf.subarray(0, lenScript).toString('hex');
    this.read(lenScript);
    var output = {
      type: type,
      amount: formatUnits(amount, 8).toString(),
      keys: keys,
      mask: mask,
      script: script
    };
    var prefix = this.subarray(0, 2);
    this.read(2);
    if (prefix.equals(magic)) {
      var address = this.readBytes();
      var tag = this.readBytes();
      output.withdrawal = {
        address: address,
        tag: tag
      };
    }
    return output;
  };
  _proto.decodeSignature = function decodeSignature() {
    var len = this.readInt();
    var sigs = {};
    for (var i = 0; i < len; i++) {
      var index = this.readInt();
      var sig = this.buf.subarray(0, 64).toString('hex');
      sigs[index] = sig;
    }
    return sigs;
  };
  return Decoder;
}();

var TxVersion = 0x02;
var getTotalBalanceFromOutputs = function getTotalBalanceFromOutputs(outputs) {
  return outputs.reduce(function (prev, cur) {
    return prev.plus(BigNumber(cur.amount));
  }, BigNumber('0'));
};
var encodeScript = function encodeScript(threshold) {
  var s = threshold.toString(16);
  if (s.length === 1) s = "0" + s;
  if (s.length > 2) throw new Error("INVALID THRESHOLD " + threshold);
  return "fffe" + s;
};
var encodeTx = function encodeTx(tx) {
  var enc = new Encoder(Buffer.from([]));
  enc.write(magic);
  enc.write(Buffer.from([0x00, tx.version]));
  enc.write(Buffer.from(tx.asset, 'hex'));
  enc.writeInt(tx.inputs.length);
  tx.inputs.forEach(function (input) {
    enc.encodeInput(input);
  });
  enc.writeInt(tx.outputs.length);
  tx.outputs.forEach(function (output) {
    enc.encodeOutput(output);
  });
  var extra = Buffer.from(tx.extra);
  enc.writeInt(extra.byteLength);
  enc.write(extra);
  enc.writeInt(0);
  enc.write(Buffer.from([]));
  return enc.buf.toString('hex');
};
/**
 * Generate raw for multi-signature transaction.
 * The total amount of input utxos should be equal to the total amount of output utxos.
 * */
var buildMultiSigsTransaction = function buildMultiSigsTransaction(transaction) {
  if (transaction.version !== TxVersion) throw new Error('Invalid Version!');
  var tx = _extends({}, transaction, {
    outputs: transaction.outputs.filter(function (output) {
      return !!output.mask;
    })
  });
  return encodeTx(tx);
};

var Prefix = 'NFO';
var Version = 0x00;
var DefaultChain = '43d61dcd-e413-450d-80b8-101d5e903357';
var DefaultClass = '3c8c161a18ae2c8b14fda1216fff7da88c419b5d';
var DefaultNftAssetId = '1700941284a95f31b25ec8c546008f208f88eee4419ccdcdbe6e3195e60128ca';
function buildTokenId(collection_id, token) {
  var tokenStr = Buffer.from(integerToBytes(token)).toString('hex');
  var msg = DefaultChain.replaceAll('-', '') + DefaultClass + collection_id.replaceAll('-', '') + tokenStr;
  var md5 = forge.md.md5.create();
  md5.update(Buffer.from(msg, 'hex').toString('binary'));
  var bytes = Buffer.from(md5.digest().bytes(), 'binary');
  bytes[6] = bytes[6] & 0x0f | 0x30;
  bytes[8] = bytes[8] & 0x3f | 0x80;
  return stringify(bytes);
}
/**
 * Content must be hex string without '0x'
 * */
function buildCollectibleMemo(content, collection_id, token_id) {
  var encoder = new Encoder(Buffer.from(Prefix, 'utf8'));
  encoder.write(Buffer.from([Version]));
  if (collection_id && token_id) {
    encoder.write(Buffer.from([1]));
    encoder.writeUint64(BigInt(1));
    encoder.writeUUID(DefaultChain);
    encoder.writeSlice(Buffer.from(DefaultClass, 'hex'));
    encoder.writeSlice(Buffer.from(parse(collection_id)));
    encoder.writeSlice(Buffer.from(integerToBytes(token_id)));
  } else {
    encoder.write(Buffer.from([0]));
  }
  encoder.writeSlice(Buffer.from(content, 'hex'));
  return encoder.buf.toString('hex');
}
var decodeNfoMemo = function decodeNfoMemo(hexMemo) {
  var memo = Buffer.from(hexMemo, 'hex');
  if (memo.byteLength < 4) throw Error("Invalid NFO memo length: " + memo.byteLength);
  var prefix = memo.subarray(0, 3).toString();
  if (prefix !== Prefix) throw Error("Invalid NFO memo prefix: " + prefix);
  var version = memo.readUint8(3);
  if (version !== Version) throw Error("Invalid NFO memo version: " + version);
  var nm = {
    prefix: Prefix,
    version: Version,
    extra: ''
  };
  var decoder = new Decoder(memo.subarray(4));
  var hint = decoder.readByte();
  if (hint === 1) {
    nm.mask = Number(decoder.readUInt64());
    if (nm.mask !== 1) throw Error("Invalid NFO memo mask: " + nm.mask);
    nm.chain = stringify(decoder.readUUID());
    if (nm.chain !== DefaultChain) throw Error("Invalid NFO memo chain: " + nm.chain);
    nm["class"] = decoder.readBytes();
    if (nm["class"] !== DefaultClass) throw Error("Invalid NFO memo chain: " + nm["class"]);
    var collection = Buffer.from(decoder.readBytes(), 'hex');
    nm.collection = stringify(collection);
    nm.token = parseInt(decoder.readBytes(), 16);
  }
  nm.extra = Buffer.from(decoder.readBytes(), 'hex').toString();
  return nm;
};
var buildNfoTransferRequest = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(client, utxo, receivers, threshold, content) {
    var keys, raw;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (content === void 0) {
              content = '';
            }
            _context.next = 3;
            return client.transfer.outputs([{
              receivers: receivers,
              index: 0
            }]);
          case 3:
            keys = _context.sent;
            raw = buildMultiSigsTransaction({
              version: 2,
              asset: DefaultNftAssetId,
              inputs: [{
                hash: utxo.transaction_hash,
                index: utxo.output_index
              }],
              outputs: [{
                amount: '1',
                mask: keys[0].mask,
                keys: keys[0].keys,
                script: encodeScript(threshold)
              }],
              extra: buildCollectibleMemo(content)
            });
            return _context.abrupt("return", client.collection.request('sign', raw));
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return function buildNfoTransferRequest(_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
}();

var TIPSequencerRegister = 'SEQUENCER:REGISTER:';
var TIPBodyForSequencerRegister = function TIPBodyForSequencerRegister(user_id, pubKey) {
  return tipBody("" + TIPSequencerRegister + user_id + pubKey);
};
var tipBody = function tipBody(s) {
  return sha256Hash(Buffer.from(s));
};

var TxVersionHashSignature = 0x05;
var OutputTypeScript = 0x00;
var OutputTypeWithdrawalSubmit = 0xa1;
/**
 * Build Payment Uri on https://mixin.one
 * Destination can be set with
 *   1. uuid: uuid of the Mixin user or bot
 *   2. mainnetAddress: Mixin mainnet address started with "XIN"
 *   3. mixAddress: address encoded with members and threshold and started with "MIX"
 *   4. members and threshold: multisigs members' uuid or mainnet address, and threshold
 */
var buildMixinOneSafePaymentUri = function buildMixinOneSafePaymentUri(params) {
  var _params$trace;
  var address = '';
  if (params.uuid && validate(params.uuid)) address = params.uuid;else if (params.mainnetAddress && getPublicFromMainnetAddress(params.mainnetAddress)) address = params.mainnetAddress;else if (params.mixAddress && parseMixAddress(params.mixAddress)) address = params.mixAddress;else if (params.members && params.threshold) {
    address = buildMixAddress({
      members: params.members,
      threshold: params.threshold
    });
  } else throw new Error('fail to get payment destination address');
  var baseUrl = "https://mixin.one/pay/" + address;
  var p = {
    asset: params.asset,
    amount: params.amount,
    memo: params.memo,
    trace: (_params$trace = params.trace) != null ? _params$trace : v4(),
    return_to: params.returnTo && encodeURIComponent(params.returnTo)
  };
  var query = qs.stringify(p);
  return baseUrl + "?" + query;
};
var signSafeRegistration = function signSafeRegistration(user_id, tipPin, privateKey) {
  var public_key = forge.pki.ed25519.publicKeyFromPrivateKey({
    privateKey: privateKey
  }).toString('hex');
  var hash = newHash(Buffer.from(user_id));
  var signData = forge.pki.ed25519.sign({
    message: hash,
    privateKey: privateKey
  });
  var signature = base64RawURLEncode(signData);
  var tipBody = TIPBodyForSequencerRegister(user_id, public_key);
  signData = forge.pki.ed25519.sign({
    message: tipBody,
    privateKey: Buffer.from(tipPin, 'hex')
  });
  return {
    public_key: public_key,
    signature: signature,
    pin_base64: signData.toString('hex')
  };
};
var deriveGhostPublicKey = function deriveGhostPublicKey(r, A, B, index) {
  var x = edwards25519.hashScalar(edwards25519.keyMultPubPriv(A, r), index);
  var p1 = edwards25519.newPoint(B);
  var p2 = edwards25519.scalarBaseMultToPoint(x);
  var p4 = p1.add(p2);
  // @ts-ignore
  return Buffer.from(p4.toRawBytes());
};
var getMainnetAddressGhostKey = function getMainnetAddressGhostKey(recipient, hexSeed) {
  if (hexSeed === void 0) {
    hexSeed = '';
  }
  if (recipient.receivers.length === 0) return undefined;
  if (hexSeed && hexSeed.length !== 128) return undefined;
  var publics = recipient.receivers.map(function (d) {
    return getPublicFromMainnetAddress(d);
  });
  if (!publics.every(function (p) {
    return !!p;
  })) return undefined;
  var seed = hexSeed ? Buffer.from(hexSeed, 'hex') : Buffer.from(forge.random.getBytesSync(64), 'binary');
  var r = Buffer.from(edwards25519.scalar.toBytes(edwards25519.setUniformBytes(seed)));
  var keys = publics.map(function (addressPubic) {
    var spendKey = addressPubic.subarray(0, 32);
    var viewKey = addressPubic.subarray(32, 64);
    var k = deriveGhostPublicKey(r, viewKey, spendKey, recipient.index);
    return k.toString('hex');
  });
  return {
    mask: edwards25519.publicFromPrivate(r).toString('hex'),
    keys: keys
  };
};
var buildSafeTransactionRecipient = function buildSafeTransactionRecipient(members, threshold, amount) {
  return {
    members: members,
    threshold: threshold,
    amount: amount,
    mixAddress: buildMixAddress({
      members: members,
      threshold: threshold
    })
  };
};
var getUnspentOutputsForRecipients = function getUnspentOutputsForRecipients(outputs, rs) {
  var totalOutput = rs.reduce(function (prev, cur) {
    return prev.plus(BigNumber(cur.amount));
  }, BigNumber('0'));
  var totalInput = BigNumber('0');
  for (var i = 0; i < outputs.length; i++) {
    var o = outputs[i];
    if (o.state !== 'unspent') continue;
    totalInput = totalInput.plus(BigNumber(o.amount));
    if (totalInput.minus(totalOutput).isNegative()) continue;
    return {
      utxos: outputs.slice(0, i + 1),
      change: totalInput.minus(totalOutput)
    };
  }
  throw new Error('insufficient total input outputs');
};
var encodeSafeTransaction = function encodeSafeTransaction(tx, sigs) {
  if (sigs === void 0) {
    sigs = [];
  }
  var enc = new Encoder(Buffer.from([]));
  enc.write(magic);
  enc.write(Buffer.from([0x00, tx.version]));
  enc.write(Buffer.from(tx.asset, 'hex'));
  enc.writeInt(tx.inputs.length);
  tx.inputs.forEach(function (input) {
    enc.encodeInput(input);
  });
  enc.writeInt(tx.outputs.length);
  tx.outputs.forEach(function (output) {
    enc.encodeOutput(output);
  });
  enc.writeInt(tx.references.length);
  tx.references.forEach(function (r) {
    enc.write(Buffer.from(r, 'hex'));
  });
  var extra = Buffer.from(tx.extra);
  enc.writeUint32(extra.byteLength);
  enc.write(extra);
  enc.writeInt(sigs.length);
  sigs.forEach(function (s) {
    enc.encodeSignature(s);
  });
  return enc.buf.toString('hex');
};
var decodeSafeTransaction = function decodeSafeTransaction(raw) {
  var dec = new Decoder(Buffer.from(raw, 'hex'));
  var prefix = dec.subarray(0, 2);
  if (!prefix.equals(magic)) throw new Error('invalid magic');
  dec.read(3);
  var version = dec.readByte();
  if (version !== TxVersionHashSignature) throw new Error('invalid version');
  var asset = dec.subarray(0, 32).toString('hex');
  dec.read(32);
  var lenInput = dec.readInt();
  var inputs = [];
  for (var i = 0; i < lenInput; i++) {
    inputs.push(dec.decodeInput());
  }
  var lenOutput = dec.readInt();
  var outputs = [];
  for (var _i = 0; _i < lenOutput; _i++) {
    outputs.push(dec.decodeOutput());
  }
  var lenRefs = dec.readInt();
  var references = [];
  for (var _i2 = 0; _i2 < lenRefs; _i2++) {
    var hash = dec.subarray(0, 32).toString('hex');
    dec.read(32);
    references.push(hash);
  }
  var lenExtra = dec.readUint32();
  var extra = dec.subarray(0, lenExtra).toString();
  dec.read(lenExtra);
  var lenSigs = dec.readInt();
  var signatureMap = [];
  for (var _i3 = 0; _i3 < lenSigs; _i3++) {
    signatureMap.push(dec.decodeSignature());
  }
  return {
    version: version,
    asset: asset,
    extra: extra,
    inputs: inputs,
    outputs: outputs,
    references: references,
    signatureMap: signatureMap
  };
};
var buildSafeTransaction = function buildSafeTransaction(utxos, rs, gs, extra, references) {
  if (references === void 0) {
    references = [];
  }
  if (utxos.length === 0) throw new Error('empty inputs');
  if (Buffer.from(extra).byteLength > 512) throw new Error('extra data is too long');
  var asset = '';
  var inputs = [];
  utxos.forEach(function (o) {
    if (!asset) asset = o.asset;
    if (o.asset !== asset) throw new Error('inconsistent asset in outputs');
    inputs.push({
      hash: o.transaction_hash,
      index: o.output_index
    });
  });
  var outputs = [];
  for (var i = 0; i < rs.length; i++) {
    var r = rs[i];
    if ('destination' in r) {
      var _r$tag;
      outputs.push({
        type: OutputTypeWithdrawalSubmit,
        amount: r.amount,
        withdrawal: {
          address: r.destination,
          tag: (_r$tag = r.tag) != null ? _r$tag : ''
        },
        keys: []
      });
      continue;
    }
    outputs.push({
      type: OutputTypeScript,
      amount: r.amount,
      keys: gs[i].keys,
      mask: gs[i].mask,
      script: encodeScript(r.threshold)
    });
  }
  return {
    version: TxVersionHashSignature,
    asset: asset,
    extra: extra,
    inputs: inputs,
    outputs: outputs,
    references: references
  };
};
var signSafeTransaction = function signSafeTransaction(tx, views, privateKey, index) {
  if (index === void 0) {
    index = 0;
  }
  var raw = encodeSafeTransaction(tx);
  var msg = blake3Hash(Buffer.from(raw, 'hex'));
  var spenty = sha512Hash(Buffer.from(privateKey.slice(0, 64), 'hex'));
  var y = edwards25519.setBytesWithClamping(spenty.subarray(0, 32));
  var signaturesMap = [];
  for (var i = 0; i < tx.inputs.length; i++) {
    var viewBuffer = Buffer.from(views[i], 'hex');
    var x = edwards25519.setCanonicalBytes(viewBuffer);
    var t = edwards25519.scalar.add(x, y);
    var key = Buffer.from(edwards25519.scalar.toBytes(t));
    var sig = edwards25519.sign(msg, key);
    var sigs = {};
    sigs[index] = sig.toString('hex');
    signaturesMap.push(sigs);
  }
  return encodeSafeTransaction(tx, signaturesMap);
};

var sleep = function sleep(n) {
  if (n === void 0) {
    n = 500;
  }
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve();
    }, n);
  });
};

var decodeMessage = function decodeMessage(data, options) {
  var t = ungzip(data, {
    to: 'string'
  });
  var msgObj = JSON.parse(t);
  if (options.parse && msgObj.data && msgObj.data.data) {
    msgObj.data.data = Buffer.from(msgObj.data.data, 'base64').toString();
    try {
      msgObj.data.data = JSON.parse(msgObj.data.data);
    } catch (e) {
      // ignore error
    }
  }
  return msgObj.data;
};
var sendRaw = function sendRaw(ws, message) {
  return new Promise(function (resolve) {
    var buffer = Buffer.from(JSON.stringify(message), 'utf-8');
    var zipped = gzip(buffer);
    if (ws.readyState === WebSocket.OPEN) {
      var timer = setTimeout(function () {
        resolve(false);
      }, 5000);
      var cb = function cb() {
        clearTimeout(timer);
        resolve(true);
      };
      ws.send(zipped, cb);
      return;
    }
    resolve(false);
  });
};

function websocket(keystore, url, handler, option) {
  if (option === void 0) {
    option = {
      parse: false,
      syncAck: false
    };
  }
  var jwtToken = signAccessToken('GET', '/', '', v4(), keystore) || '';
  var headers = {
    Authorization: "Bearer " + jwtToken
  };
  var ws = new WebSocket(url, 'Mixin-Blaze-1', {
    headers: headers,
    handshakeTimeout: 3000
  });
  ws.onmessage = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {
      var msg, message;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              msg = decodeMessage(event.data, option);
              if (msg) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return");
            case 3:
              if (!(msg.source === 'ACKNOWLEDGE_MESSAGE_RECEIPT' && handler.onAckReceipt)) {
                _context.next = 8;
                break;
              }
              _context.next = 6;
              return handler.onAckReceipt(msg);
            case 6:
              _context.next = 20;
              break;
            case 8:
              if (!(msg.category === 'SYSTEM_CONVERSATION' && handler.onConversation)) {
                _context.next = 13;
                break;
              }
              _context.next = 11;
              return handler.onConversation(msg);
            case 11:
              _context.next = 20;
              break;
            case 13:
              if (!(msg.category === 'SYSTEM_ACCOUNT_SNAPSHOT' && handler.onTransfer)) {
                _context.next = 18;
                break;
              }
              _context.next = 16;
              return handler.onTransfer(msg);
            case 16:
              _context.next = 20;
              break;
            case 18:
              _context.next = 20;
              return handler.onMessage(msg);
            case 20:
              if (!option.syncAck) {
                _context.next = 24;
                break;
              }
              message = {
                id: v4(),
                action: 'ACKNOWLEDGE_MESSAGE_RECEIPT',
                params: {
                  message_id: msg.message_id,
                  status: 'READ'
                }
              };
              _context.next = 24;
              return sendRaw(ws, message);
            case 24:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return ws;
}

var wsHostURL = ['wss://mixin-blaze.zeromesh.net', 'wss://blaze.mixin.one/'];
var BlazeKeystoreClient = function BlazeKeystoreClient(keystore, wsOptions) {
  var url = wsHostURL[0];
  var ws;
  var pingTimeout;
  var terminate = function terminate() {
    clearTimeout(Number(pingTimeout));
    if (!ws) return;
    ws.terminate();
    ws = undefined;
  };
  var heartbeat = function heartbeat() {
    clearTimeout(Number(pingTimeout));
    pingTimeout = setTimeout(terminate, 1000 * 30);
  };
  var loopBlaze = function loopBlaze(h) {
    if (ws) return;
    ws = websocket(keystore, url, h, wsOptions);
    heartbeat();
    ws.on('ping', heartbeat);
    ws.onopen = function () {
      heartbeat();
      if (ws) sendRaw(ws, {
        id: v4(),
        action: 'LIST_PENDING_MESSAGES'
      });
    };
    ws.onclose = function () {
      terminate();
      loopBlaze(h);
    };
    ws.onerror = function (e) {
      if (e.message !== 'Opening handshake has timed out') return;
      url = url === wsHostURL[0] ? wsHostURL[1] : wsHostURL[0];
      terminate();
    };
  };
  return {
    loop: function loop(h) {
      if (ws) throw new Error('Blaze is already running');
      if (!h.onMessage) throw new Error('OnMessage not set');
      loopBlaze(h);
    },
    stopLoop: function stopLoop() {
      terminate();
    },
    getWebSocket: function getWebSocket() {
      return ws;
    }
  };
};
var BlazeClient = function BlazeClient(keystore, wsOptions) {
  return {
    blaze: BlazeKeystoreClient(keystore, wsOptions)
  };
};

/**
 * Circle is used to classify conversations
 * User can have no more than 64 circles
 * Docs: https://developers.mixin.one/docs/api/circles/list
 */
var CircleKeystoreClient = function CircleKeystoreClient(axiosInstance) {
  return {
    /** Get the details of a certain circle */
    fetch: function fetch(circleID) {
      return axiosInstance.get("/circles/" + circleID);
    },
    /** Get all circles of a user */
    fetchList: function fetchList() {
      return axiosInstance.get('/circles');
    },
    /** Get all the conversations in a circle of a user */
    conversations: function conversations(circleID, params) {
      return axiosInstance.get("/circles/" + circleID + "/conversations", {
        params: params
      });
    },
    /** Create a circle */
    create: function create(name) {
      return axiosInstance.post('/circles', {
        name: name
      });
    },
    /** Modify the circle name */
    update: function update(circleID, name) {
      return axiosInstance.post("/circles/" + circleID, {
        name: name
      });
    },
    /** Delete a circle */
    "delete": function _delete(circleID) {
      return axiosInstance.post("/circles/" + circleID + "/delete");
    },
    /** Add the user to  a circle */
    addUser: function addUser(userID, circleID) {
      return axiosInstance.post("/users/" + userID + "/circles", {
        circleID: circleID,
        action: 'ADD'
      });
    },
    /** Remove the user from a circle */
    removeUser: function removeUser(userID, circleID) {
      return axiosInstance.post("/users/" + userID + "/circles", {
        circleID: circleID,
        action: 'REMOVE'
      });
    },
    /** Add the group from a certain circle */
    addConversation: function addConversation(conversationID, circleID) {
      return axiosInstance.post("/conversations/" + conversationID + "/circles", {
        circleID: circleID,
        action: 'ADD'
      });
    },
    /** Remove the group from a certain circle */
    removeConversation: function removeConversation(conversation_id, circleID) {
      return axiosInstance.post("/conversations/" + conversation_id + "/circles", {
        circleID: circleID,
        action: 'REMOVE'
      });
    }
  };
};
var CircleClient = /*#__PURE__*/buildClient(CircleKeystoreClient);

/**
 * Some information in Mixin is non-public, through codes/:id you can share it.
 * It also facilitates privacy protection
 */
var CodeKeystoreClient = function CodeKeystoreClient(axiosInstance) {
  return {
    fetch: function fetch(codeID) {
      return axiosInstance.get("/codes/" + codeID);
    }
  };
};
var CodeClient = /*#__PURE__*/buildClient(CodeKeystoreClient);

var MintMinimumCost = '0.001';
var GroupMembers = ['4b188942-9fb0-4b99-b4be-e741a06d1ebf', 'dd655520-c919-4349-822f-af92fabdbdf4', '047061e6-496d-4c35-b06b-b0424a8a400d', 'acf65344-c778-41ee-bacb-eb546bacfb9f', 'a51006d0-146b-4b32-a2ce-7defbf0d7735', 'cf4abd9c-2cfa-4b5a-b1bd-e2b61a83fabd', '50115496-7247-4e2c-857b-ec8680756bee'];
var GroupThreshold = 5;
/**
 * Users can use those APIs to manage their NFTs
 * Note:
 * * Before transferring a collectible, user should create a request first.
 * * only unsigned request can be canceled.
 * * only uncompleted sign transaction can be unlocked.
 * Docs: https://developers.mixin.one/docs/api/collectibles/request
 */
var CollectibleKeystoreClient = function CollectibleKeystoreClient(axiosInstance, keystore) {
  var manageRequest = function manageRequest(pin, requestID, action) {
    var encrypted = signEd25519PIN(pin, keystore);
    return axiosInstance.post("/collectibles/requests/" + requestID + "/" + action, {
      pin: encrypted
    });
  };
  var transfer = function transfer(action, raw) {
    return axiosInstance.post('/collectibles/requests', {
      action: action,
      raw: raw
    });
  };
  return {
    /** Get the information of the collectible */
    fetch: function fetch(tokenID) {
      return axiosInstance.get("/collectibles/tokens/" + tokenID);
    },
    /** Get the information of the collectible collection */
    fetchCollection: function fetchCollection(collectionID) {
      return axiosInstance.get("/collectibles/collections/" + collectionID);
    },
    /** Get collectibles outputs */
    outputs: function outputs(params) {
      var hashedParams = _extends({}, params, {
        members: hashMembers(params.members)
      });
      return axiosInstance.get('/collectibles/outputs', {
        params: hashedParams
      });
    },
    /** @deprecated Use transfer() instead */
    request: transfer,
    /** Create a collectibles transfer request */
    transfer: transfer,
    /** Initiate or participate in signing */
    sign: function sign(pin, requestID) {
      return manageRequest(pin, requestID, 'sign');
    },
    /** Cancel my signature */
    cancel: function cancel(pin, requestID) {
      return manageRequest(pin, requestID, 'cancel');
    },
    /** Cancel collectibles */
    unlock: function unlock(pin, requestID) {
      return manageRequest(pin, requestID, 'unlock');
    }
  };
};
var CollectibleClient = /*#__PURE__*/buildClient(CollectibleKeystoreClient);

/**
 * Create and manage a conversation
 * Notes:
 * * only owner and admin can add or remove participants, and rotate conversation code
 * * only owner can change the role of participants
 * * only owner and admin can setup disappear
 * * for group conversation, creator will be the owner and can't be changed.
 * Docs: https://developers.mixin.one/docs/api/conversations/read
 */
var ConversationKeystoreClient = function ConversationKeystoreClient(axiosInstance, keystore) {
  var createConversation = function createConversation(params) {
    return axiosInstance.post('/conversations', params);
  };
  var managerConversation = function managerConversation(conversationID, action, participant) {
    return axiosInstance.post("/conversations/" + conversationID + "/participants/" + action, participant);
  };
  var createContactConversation = function createContactConversation(userID) {
    if (!keystore) throw new Error('No Keystore Provided');
    return createConversation({
      category: 'CONTACT',
      conversation_id: uniqueConversationID(keystore.app_id, userID),
      participants: [{
        user_id: userID
      }]
    });
  };
  var muteConversation = function muteConversation(conversationID, duration) {
    return axiosInstance.post("/conversations/" + conversationID + "/mute", {
      duration: duration
    });
  };
  return {
    /** Get specific conversation information by conversationID */
    fetch: function fetch(conversationID) {
      return axiosInstance.get("/conversations/" + conversationID);
    },
    /**
     * Ensure the conversation is created
     * when creating a new group or having a conversation with a user
     * for the first time.
     */
    create: createConversation,
    /** Create a conversation with a user for the first time */
    createContact: createContactConversation,
    /** Create a new group for the first time */
    createGroup: function createGroup(conversationID, name, participant) {
      return createConversation({
        category: 'GROUP',
        conversation_id: conversationID,
        name: name,
        participants: participant
      });
    },
    /** Join a group by codeID */
    joinGroup: function joinGroup(codeID) {
      return axiosInstance.post("/conversations/" + codeID + "/join");
    },
    /** Exit a group */
    exitGroup: function exitGroup(conversationID) {
      return axiosInstance.post("/conversations/" + conversationID + "/exit");
    },
    /** Add/remove other participants or add/remove admin in a group */
    updateParticipants: managerConversation,
    /** Add users, if you are the owner or admin of this group conversation */
    addParticipants: function addParticipants(conversationID, userIDs) {
      return managerConversation(conversationID, 'ADD', userIDs.map(function (userID) {
        return {
          user_id: userID
        };
      }));
    },
    /** Remove users, if you are the owner or admin of this group conversation */
    removeParticipants: function removeParticipants(conversationID, userIDs) {
      return managerConversation(conversationID, 'REMOVE', userIDs.map(function (userID) {
        return {
          user_id: userID
        };
      }));
    },
    /** Set admin privileges for a user, group owners Only */
    setAdmin: function setAdmin(conversationID, userIDs) {
      return managerConversation(conversationID, 'ROLE', userIDs.map(function (userID) {
        return {
          user_id: userID,
          role: 'ADMIN'
        };
      }));
    },
    /** Remove admin privileges for a user, group owners Only */
    revokeAdmin: function revokeAdmin(conversationID, userIDs) {
      return managerConversation(conversationID, 'ROLE', userIDs.map(function (userID) {
        return {
          user_id: userID,
          role: ''
        };
      }));
    },
    /** Reset invitation link and codeId */
    resetGroupCode: function resetGroupCode(conversationID) {
      return axiosInstance.post("/conversations/" + conversationID + "/rotate");
    },
    /** Update a group's title and announcement by conversationID */
    updateGroupInfo: function updateGroupInfo(conversationID, params) {
      return axiosInstance.post("/conversations/" + conversationID, params);
    },
    /** Mute contact for <duration> seconds */
    mute: function mute(conversationID, duration) {
      return muteConversation(conversationID, duration);
    },
    /** Unmute contact */
    unmute: function unmute(conversationID) {
      return muteConversation(conversationID, 0);
    },
    /** Set the disappearing message expiration duration for group */
    disappearDuration: function disappearDuration(conversationID, duration) {
      return axiosInstance.post("/conversations/" + conversationID + "/disappear", {
        duration: duration
      });
    }
  };
};
var ConversationClient = /*#__PURE__*/buildClient(ConversationKeystoreClient);

var ExternalKeystoreClient = function ExternalKeystoreClient(axiosInstance) {
  return {
    /**
     * Get the pending deposits
     * Which confirmations is less then threshold
     */
    deposits: function deposits(params) {
      return axiosInstance.get('/external/transactions', {
        params: params
      });
    },
    /**
     * Check if an address belongs to Mixin
     */
    checkAddress: function checkAddress(params) {
      return axiosInstance.get("/external/addresses/check", {
        params: params
      });
    },
    /**
     * GET the list of all fiat exchange rates based on US Dollar
     */
    exchangeRates: function exchangeRates() {
      return axiosInstance.get('/external/fiats');
    },
    /**
     * Submit a raw transaction to a random mainnet node
     *   {
     *     method: 'sendrawtransaction',
     *     params: array of transaction hash
     *   }
     * */
    proxy: function proxy(params) {
      return axiosInstance.post('/external/proxy', params);
    }
  };
};
var ExternalClient = /*#__PURE__*/buildClient(ExternalKeystoreClient);

/**
 * Methods to send messages
 * Note:
 * * To receive a list of messages from Mixin message service, you need to setup a websocket connection.
 *   After receiving the message via WebSocket, you need to acknowledge the message to Mixin message service,
 *   otherwise it will keep pushing the message.
 */
var MessageKeystoreClient = function MessageKeystoreClient(axiosInstance, keystore) {
  var send = function send(message) {
    return axiosInstance.post('/messages', [message]);
  };
  var sendMsg = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(recipientID, category, data) {
      var messageRequest;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (keystore) {
                _context.next = 2;
                break;
              }
              throw new Error('No Keystore Provided');
            case 2:
              if (typeof data === 'object') data = JSON.stringify(data);
              messageRequest = {
                category: category,
                recipient_id: recipientID,
                conversation_id: uniqueConversationID(keystore.app_id, recipientID),
                message_id: v4(),
                data: base64RawURLEncode(Buffer.from(data))
              };
              _context.next = 6;
              return send(messageRequest);
            case 6:
              return _context.abrupt("return", messageRequest);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function sendMsg(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    /** Send the status of single message in bulk to Mixin Server */
    sendAcknowledgement: function sendAcknowledgement(message) {
      return axiosInstance.post('/acknowledgements', [message]);
    },
    /** Send the status of messages in bulk to Mixin Server */
    sendAcknowledges: function sendAcknowledges(messages) {
      return axiosInstance.post('/acknowledgements', messages);
    },
    /** Send one message */
    sendOne: send,
    /**
     * Send messages in bulk
     * A maximum of 100 messages can be sent in batch each time, and the message body cannot exceed 128Kb
     */
    sendBatch: function sendBatch(messages) {
      return axiosInstance.post('/messages', messages);
    },
    /** send one kind of message */
    sendMsg: sendMsg,
    sendText: function sendText(userID, text) {
      return sendMsg(userID, 'PLAIN_TEXT', text);
    },
    sendSticker: function sendSticker(userID, sticker) {
      return sendMsg(userID, 'PLAIN_STICKER', sticker);
    },
    sendImage: function sendImage(userID, image) {
      return sendMsg(userID, 'PLAIN_IMAGE', image);
    },
    sendAudio: function sendAudio(userID, audio) {
      return sendMsg(userID, 'PLAIN_AUDIO', audio);
    },
    sendVideo: function sendVideo(userID, video) {
      return sendMsg(userID, 'PLAIN_VIDEO', video);
    },
    sendContact: function sendContact(userID, contact) {
      return sendMsg(userID, 'PLAIN_CONTACT', contact);
    },
    sendAppCard: function sendAppCard(userID, appCard) {
      return sendMsg(userID, 'APP_CARD', appCard);
    },
    sendFile: function sendFile(userID, file) {
      return sendMsg(userID, 'PLAIN_DATA', file);
    },
    sendLive: function sendLive(userID, live) {
      return sendMsg(userID, 'PLAIN_LIVE', live);
    },
    sendLocation: function sendLocation(userID, location) {
      return sendMsg(userID, 'PLAIN_LOCATION', location);
    },
    sendPost: function sendPost(userID, text) {
      return sendMsg(userID, 'PLAIN_POST', text);
    },
    sendAppButton: function sendAppButton(userID, appButton) {
      return sendMsg(userID, 'APP_BUTTON_GROUP', appButton);
    },
    sendTransfer: function sendTransfer(userID, transfer) {
      return sendMsg(userID, 'SYSTEM_ACCOUNT_SNAPSHOT', transfer);
    },
    sendRecall: function sendRecall(userID, message) {
      return sendMsg(userID, 'MESSAGE_RECALL', message);
    }
  };
};
var MessageClient = /*#__PURE__*/buildClient(MessageKeystoreClient);

/**
 * Users can use those APIs to manage their multisig outputs
 * Note:
 * * Before transferring tokens, user should create a request first.
 * * only unsigned request can be canceled.
 * * only uncompleted sign transaction can be unlocked.
 * Docs: https://developers.mixin.one/docs/api/multisigs/request
 */
var MultisigKeystoreClient = function MultisigKeystoreClient(axiosInstance, keystore) {
  var initMultisig = function initMultisig(pin, requestID, action) {
    var encrypted = signEd25519PIN(pin, keystore);
    return axiosInstance.post("/multisigs/requests/" + requestID + "/" + action, {
      pin: encrypted
    });
  };
  return {
    /** Get signature outputs, if an account participates in it */
    outputs: function outputs(params) {
      var members = params.members,
        threshold = params.threshold;
      if (members.length === 0 || threshold < 1 || threshold > members.length) return Promise.reject(new Error('Invalid threshold or members'));
      var hashedParams = _extends({}, params, {
        members: hashMembers(members)
      });
      return axiosInstance.get("/multisigs/outputs", {
        params: hashedParams
      });
    },
    /** Generate a multi-signature request to obtain request_id */
    create: function create(action, raw) {
      return axiosInstance.post("/multisigs/requests", {
        action: action,
        raw: raw
      });
    },
    /** Initiate or participate in signing */
    sign: function sign(pin, requestID) {
      return initMultisig(pin, requestID, 'sign');
    },
    /** Cancel my signature before the multisig finish */
    unlock: function unlock(pin, requestID) {
      return initMultisig(pin, requestID, 'unlock');
    },
    /** Cancel my multisig request */
    cancel: function cancel(pin, requestID) {
      return initMultisig(pin, requestID, 'cancel');
    },
    createSafeMultisigs: function createSafeMultisigs(params) {
      return axiosInstance.post('/safe/multisigs', params);
    },
    fetchSafeMultisigs: function fetchSafeMultisigs(id) {
      return axiosInstance.get("/safe/multisigs/" + id);
    },
    signSafeMultisigs: function signSafeMultisigs(id, raw) {
      return axiosInstance.post("/safe/multisigs/" + id + "/sign", {
        raw: raw
      });
    },
    unlockSafeMultisigs: function unlockSafeMultisigs(id) {
      return axiosInstance.post("/safe/multisigs/" + id + "/unlock");
    }
  };
};
var MultisigClient = /*#__PURE__*/buildClient(MultisigKeystoreClient);

/**
 * Public methods that need no permission
 * Docs: https://developers.mixin.one/docs/api/transfer/snapshots
 */
var NetworkBaseClient = function NetworkBaseClient(axiosInstance) {
  return {
    /** Get network info */
    info: function info() {
      return axiosInstance.get('/network');
    },
    /** Get the list of all public chains supported by Mixin */
    chains: function chains() {
      return axiosInstance.get('/network/chains');
    },
    /** Get information of a chain */
    fetchChain: function fetchChain(chainID) {
      return axiosInstance.get("/network/chains/" + chainID);
    },
    /** Get public information of an asset */
    fetchAsset: function fetchAsset(assetID) {
      return axiosInstance.get("/network/assets/" + assetID);
    },
    /**
     * Get the list of the top 100 assets on the entire network
     * kind parameter is used to specify the top assets, for NORMAL value will not swap lp tokens
     */
    topAssets: function topAssets(kind) {
      if (kind === void 0) {
        kind = 'ALL';
      }
      var params = {
        kind: kind
      };
      return axiosInstance.get('/network/assets/top', {
        params: params
      });
    },
    /**
     * Search for popular assets by symbol or name
     * This API only returns assets with icons or prices.
     */
    searchAssets: function searchAssets(keyword, kind) {
      if (kind === void 0) {
        kind = 'ALL';
      }
      var params = {
        kind: kind
      };
      return axiosInstance.get("/network/assets/search/" + keyword, {
        params: params
      });
    },
    /**
     * Get the historical price of a given asset
     * If no ticker found, price_usd and price_usd will return 0
     */
    historicalPrice: function historicalPrice(assetID, offset) {
      var params = {
        asset: assetID,
        offset: offset
      };
      return axiosInstance.get("/network/ticker", {
        params: params
      });
    },
    /** Get public information of specific snapshot by snapshot_id */
    snapshot: function snapshot(snapshotID) {
      return axiosInstance.get("/network/snapshots/" + snapshotID);
    },
    /** Get public information of snapshot records, which including transfers, deposits, withdrawals, etc */
    snapshots: function snapshots(inputParams) {
      var params = _extends({}, inputParams, {
        order: inputParams.order || 'DESC'
      });
      return axiosInstance.get("/network/snapshots", {
        params: params
      });
    }
  };
};
var NetworkClient = /*#__PURE__*/buildClient(NetworkBaseClient);

/**
 * Method to get user access code
 * To access some information of Mixin Messenger users, the developer needs to apply for authorization from the user
 * After that, the page will automatically jump to the application's OAuth URL, accompanied by the authorization code
 * Detail: https://developers.mixin.one/docs/api/oauth/oauth
 */
var OAuthBaseClient = function OAuthBaseClient(axiosInstance) {
  return {
    /** Get the access code based on authorization code */
    getToken: function getToken(data) {
      return axiosInstance.post('/oauth/token', data);
    },
    authorize: function authorize(data) {
      return axiosInstance.post('/oauth/authorize', data);
    },
    authorizations: function authorizations(appId) {
      return axiosInstance.get('/authorizations', {
        params: {
          app: appId
        }
      });
    },
    revokeAuthorize: function revokeAuthorize(clientId) {
      return axiosInstance.post('/oauth/cancel', {
        client_id: clientId
      });
    }
  };
};
var OAuthClient = /*#__PURE__*/buildClient(OAuthBaseClient);

var PaymentBaseClient = function PaymentBaseClient(axiosInstance) {
  var payment = function payment(params) {
    return axiosInstance.post('/payments', params);
  };
  return {
    /** @deprecated Use payment() instead */
    request: payment,
    // Generate code id for transaction/transfer or verify payments by trace id
    payment: payment
  };
};
var PaymentClient = /*#__PURE__*/buildClient(PaymentBaseClient);

/**
 * Methods to verify or update pin with keystore
 * Note:
 * * If you forget your PIN, there is no way to retrieve or restore it
 * Docs: https://developers.mixin.one/docs/api/pin/pin-update
 */
var PinKeystoreClient = function PinKeystoreClient(axiosInstance, keystore) {
  function updatePin(firstPin, secondPin) {
    if (secondPin === void 0) {
      secondPin = '';
    }
    var oldEncrypted = firstPin ? signEd25519PIN(firstPin, keystore) : '';
    var newEncrypted = signEd25519PIN(secondPin, keystore);
    return axiosInstance.post('/pin/update', {
      old_pin_base64: oldEncrypted,
      pin_base64: newEncrypted
    });
  }
  function updateTipPin(firstPin, secondPin, counter) {
    var pubTipBuf = Buffer.from(secondPin, 'hex');
    if (pubTipBuf.byteLength !== 32) throw new Error('invalid public key');
    var pubTipHex = getTipPinUpdateMsg(pubTipBuf, counter).toString('hex');
    var oldEncrypted = firstPin ? signEd25519PIN(firstPin, keystore) : '';
    var newEncrypted = signEd25519PIN(pubTipHex, keystore);
    return axiosInstance.post('/pin/update', {
      old_pin_base64: oldEncrypted,
      pin_base64: newEncrypted
    });
  }
  return {
    /** Verify a user's PIN, the iterator of the pin will increment also */
    verify: function verify(pin) {
      var encrypted = signEd25519PIN(pin, keystore);
      return axiosInstance.post('/pin/verify', {
        pin: encrypted
      });
    },
    verifyTipPin: function verifyTipPin(pin) {
      var timestamp = getNanoTime();
      var msg = getVerifyPinTipBody(timestamp);
      var signedTipPin = signTipBody(pin, msg);
      return axiosInstance.post('/pin/verify', {
        pin_base64: signEd25519PIN(signedTipPin, keystore),
        timestamp: timestamp
      });
    },
    /** Change the PIN of the user, or setup a new PIN if it is not set yet */
    update: updatePin,
    updateTipPin: updateTipPin
  };
};
var PinClient = /*#__PURE__*/buildClient(PinKeystoreClient);

var SafeKeystoreClient = function SafeKeystoreClient(axiosInstance, keystore) {
  return {
    /** If you want to register safe user, you need to upgrade TIP PIN first. */
    register: function register(user_id, tipPin, priv) {
      var data = signSafeRegistration(user_id, tipPin, priv);
      data.pin_base64 = signEd25519PIN(data.pin_base64, keystore);
      return axiosInstance.post('/safe/users', data);
    },
    checkRegisteration: function checkRegisteration() {
      return axiosInstance.get("/safe/me");
    },
    assets: function assets() {
      return axiosInstance.get('/safe/assets');
    },
    fetchAsset: function fetchAsset(id) {
      return axiosInstance.get("/safe/assets/" + id);
    },
    fetchAssets: function fetchAssets(assetIds) {
      return axiosInstance.post("/safe/assets/fetch", assetIds);
    },
    fetchFee: function fetchFee(asset, destination) {
      return axiosInstance.get("/safe/assets/" + asset + "/fees", {
        params: {
          destination: destination
        }
      });
    },
    depositEntries: function depositEntries(data) {
      return axiosInstance.post("/safe/deposit/entries", data);
    },
    createDeposit: function createDeposit(chain_id) {
      return axiosInstance.post('/safe/deposit/entries', {
        chain_id: chain_id
      });
    },
    pendingDeposits: function pendingDeposits(params) {
      return axiosInstance.get("/safe/deposits", {
        params: params
      });
    },
    /**
     * Get snapshots for single user
     * Or Get snapshots for all network users with app uuid passed
     */
    fetchSafeSnapshots: function fetchSafeSnapshots(data) {
      return axiosInstance.get("/safe/snapshots", {
        params: data
      });
    },
    fetchSafeSnapshot: function fetchSafeSnapshot(id) {
      return axiosInstance.get("/safe/snapshots/" + id);
    }
  };
};
var SafeClient = /*#__PURE__*/buildClient(SafeKeystoreClient);

/**
 * Methods to transfer asset, withdraw and obtain transfer information
 * Note:
 * * Once /transfers API is successfully called, it means data has been confirmed by all nodes, and it is irreversible
 * Docs: https://developers.mixin.one/docs/api/transfer/transfer
 */
var TransferKeystoreClient = function TransferKeystoreClient(axiosInstance, keystore) {
  return {
    /** Get transfer information by traceID */
    fetch: function fetch(traceID) {
      return axiosInstance.get("/transfers/trace/" + traceID);
    },
    /** Get specific snapshot of current user */
    snapshot: function snapshot(snapshotID) {
      return axiosInstance.get("/snapshots/" + snapshotID);
    },
    /** Get the snapshots of current user */
    snapshots: function snapshots(params) {
      return axiosInstance.get("/snapshots", {
        params: params
      });
    },
    /**
     * Transfer to specific user
     * If you encounter 500 error, do it over again
     * If you see the error 20119 password is wrong, do not try again. It is recommended to call the PIN Verification API to confirm
     */
    toUser: function toUser(pin, params) {
      var request = _extends({}, params, {
        pin: signEd25519PIN(pin, keystore)
      });
      return axiosInstance.post('/transfers', request);
    },
    /** Send raw transactions to the mainnet or multisig address */
    toAddress: function toAddress(pin, params) {
      var request = _extends({}, params, {
        pin: signEd25519PIN(pin, keystore)
      });
      return axiosInstance.post('/transactions', request);
    },
    /** Get one-time user keys for mainnet */
    outputs: function outputs(input) {
      return axiosInstance.post("/outputs", input);
    }
  };
};
var TransferClient = /*#__PURE__*/buildClient(TransferKeystoreClient);

/** Methods to obtain or edit users' profile and relationships */
var UserKeystoreClient = function UserKeystoreClient(axiosInstance) {
  return {
    /** Get the current user's personal information */
    profile: function profile() {
      return axiosInstance.get("/me");
    },
    /** Get the contact list of the users, containing users and bots */
    friends: function friends() {
      return axiosInstance.get("/friends");
    },
    /** Get users' block list */
    blockings: function blockings() {
      return axiosInstance.get("/blocking_users");
    },
    /** Rotate user's code */
    rotateCode: function rotateCode() {
      return axiosInstance.get('/me/code');
    },
    /** Search users by keyword */
    search: function search(identityNumberOrPhone) {
      return axiosInstance.get("/search/" + identityNumberOrPhone);
    },
    /** Get user information by userID */
    fetch: function fetch(id) {
      return axiosInstance.get("/users/" + id);
    },
    /**
     * Get users' information by userIDs in bulk
     * This API will only return the list of existing users
     */
    fetchList: function fetchList(userIDs) {
      return axiosInstance.post("/users/fetch", userIDs);
    },
    /** Create a network user, can be created by bot only with no permission */
    createBareUser: function createBareUser(fullName, sessionSecret) {
      return axiosInstance.post('/users', {
        full_name: fullName,
        session_secret: sessionSecret
      });
    },
    /** Modify current user's personal name and avatar */
    update: function update(fullName, avatarBase64) {
      return axiosInstance.post("/me", {
        full_name: fullName,
        avatar_base64: avatarBase64
      });
    },
    /** update user's preferences */
    updatePreferences: function updatePreferences(params) {
      return axiosInstance.post("/me/preferences", params);
    },
    /** Manage the relationship between two users, one can 'ADD' | 'REMOVE' | 'BLOCK' | 'UNBLOCK' a user */
    updateRelationships: function updateRelationships(relationship) {
      return axiosInstance.post("/relationships", relationship);
    },
    /** Get pin logs of user */
    logs: function logs(params) {
      return axiosInstance.get("/logs", {
        params: params
      });
    }
  };
};
var UserClient = /*#__PURE__*/buildClient(UserKeystoreClient);

var UtxoKeystoreClient = function UtxoKeystoreClient(axiosInstance) {
  return {
    outputs: function outputs(params) {
      return axiosInstance.get("/outputs", {
        params: _extends({}, params, {
          members: hashMembers(params.members)
        })
      });
    },
    /**
     * Utxos of current user will be returned, if members and threshold are not provided.
     */
    safeOutputs: function safeOutputs(params) {
      return axiosInstance.get("/safe/outputs", {
        params: _extends({}, params, {
          members: params.members ? hashMembers(params.members) : undefined
        })
      });
    },
    safeAssetBalance: function () {
      var _safeAssetBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
        var outputs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return axiosInstance.get("/safe/outputs", {
                  params: _extends({}, params, {
                    members: params.members ? hashMembers(params.members) : undefined,
                    state: 'unspent'
                  })
                });
              case 2:
                outputs = _context.sent;
                return _context.abrupt("return", getTotalBalanceFromOutputs(outputs).toString());
              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function safeAssetBalance(_x) {
        return _safeAssetBalance.apply(this, arguments);
      }
      return safeAssetBalance;
    }(),
    fetchSafeOutputs: function fetchSafeOutputs(params) {
      return axiosInstance.post('/safe/outputs/fetch', params);
    },
    fetchTransaction: function fetchTransaction(transactionId) {
      return axiosInstance.get("/safe/transactions/" + transactionId);
    },
    verifyTransaction: function verifyTransaction(params) {
      return axiosInstance.post('/safe/transaction/requests', params);
    },
    sendTransactions: function sendTransactions(params) {
      return axiosInstance.post('/safe/transactions', params);
    },
    /**
     * Get one-time information to transfer assets to single user or multisigs group, not required for Mixin Kernel Address
     * index in GhostKeyRequest MUST be the same with the index of corresponding output
     * receivers will be sorted in the function
     */
    ghostKey: function ghostKey(params) {
      params = params.map(function (p) {
        return _extends({}, p, {
          receivers: p.receivers.sort()
        });
      });
      return axiosInstance.post('/safe/keys', params);
    }
  };
};
var UtxoClient = /*#__PURE__*/buildClient(UtxoKeystoreClient);

var KeystoreClient = function KeystoreClient(axiosInstance, keystore, config) {
  return {
    address: AddressKeystoreClient(axiosInstance, keystore),
    app: AppKeystoreClient(axiosInstance),
    asset: AssetKeystoreClient(axiosInstance),
    blaze: BlazeKeystoreClient(keystore, config.blazeOptions),
    attachment: AttachmentKeystoreClient(axiosInstance),
    circle: CircleKeystoreClient(axiosInstance),
    code: CodeKeystoreClient(axiosInstance),
    collection: CollectibleKeystoreClient(axiosInstance, keystore),
    conversation: ConversationKeystoreClient(axiosInstance, keystore),
    external: ExternalKeystoreClient(axiosInstance),
    message: MessageKeystoreClient(axiosInstance, keystore),
    multisig: MultisigKeystoreClient(axiosInstance, keystore),
    network: NetworkBaseClient(axiosInstance),
    oauth: OAuthBaseClient(axiosInstance),
    payment: PaymentBaseClient(axiosInstance),
    pin: PinKeystoreClient(axiosInstance, keystore),
    safe: SafeKeystoreClient(axiosInstance, keystore),
    transfer: TransferKeystoreClient(axiosInstance, keystore),
    user: UserKeystoreClient(axiosInstance),
    utxo: UtxoKeystoreClient(axiosInstance)
  };
};
function MixinApi(config) {
  if (config === void 0) {
    config = {};
  }
  var _config = config,
    keystore = _config.keystore,
    requestConfig = _config.requestConfig;
  var axiosInstance = createAxiosClient(keystore, requestConfig);
  var requestClient = createRequestClient(axiosInstance);
  var keystoreClient = KeystoreClient(axiosInstance, keystore, config);
  return merge(keystoreClient, requestClient);
}

var WebViewApi = function WebViewApi() {
  var getMixinContext = function getMixinContext() {
    var ctx = {};
    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.MixinContext) {
      var contextString = prompt('MixinContext.getContext()'); // eslint-disable-line no-alert
      if (contextString) {
        ctx = JSON.parse(contextString);
        ctx.platform = ctx.platform || 'iOS';
      }
    } else if (window.MixinContext && typeof window.MixinContext.getContext === 'function') {
      ctx = JSON.parse(window.MixinContext.getContext());
      ctx.platform = ctx.platform || 'Android';
    }
    return ctx;
  };
  return {
    getMixinContext: getMixinContext,
    reloadTheme: function reloadTheme() {
      switch (getMixinContext().platform) {
        case 'iOS':
          if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.reloadTheme) window.webkit.messageHandlers.reloadTheme.postMessage('');
          break;
        case 'Android':
        case 'Desktop':
          if (window.MixinContext && typeof window.MixinContext.reloadTheme === 'function') window.MixinContext.reloadTheme();
          break;
      }
    },
    playlist: function playlist(audios) {
      switch (getMixinContext().platform) {
        case 'iOS':
          if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.playlist) window.webkit.messageHandlers.playlist.postMessage(audios);
          break;
        case 'Android':
        case 'Desktop':
          if (window.MixinContext && typeof window.MixinContext.playlist === 'function') window.MixinContext.playlist(audios);
          break;
      }
    },
    close: function close() {
      switch (getMixinContext().platform) {
        case 'iOS':
          if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.close) window.webkit.messageHandlers.close.postMessage('');
          break;
        case 'Android':
        case 'Desktop':
          if (window.MixinContext && typeof window.MixinContext.close === 'function') window.MixinContext.close();
          break;
      }
    },
    getAssets: function () {
      var _getAssets = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(assets, cb) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = getMixinContext().platform;
                _context.next = _context.t0 === 'iOS' ? 3 : _context.t0 === 'Android' ? 8 : _context.t0 === 'Desktop' ? 8 : 13;
                break;
              case 3:
                if (!(window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.getAssets)) {
                  _context.next = 7;
                  break;
                }
                window.assetsCallbackFunction = cb;
                _context.next = 7;
                return window.webkit.messageHandlers.getAssets.postMessage([assets, 'assetsCallbackFunction']);
              case 7:
                return _context.abrupt("break", 14);
              case 8:
                if (!(window.MixinContext && typeof window.MixinContext.getAssets === 'function')) {
                  _context.next = 12;
                  break;
                }
                window.assetsCallbackFunction = cb;
                _context.next = 12;
                return window.MixinContext.getAssets(assets, 'assetsCallbackFunction');
              case 12:
                return _context.abrupt("break", 14);
              case 13:
                return _context.abrupt("break", 14);
              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function getAssets(_x, _x2) {
        return _getAssets.apply(this, arguments);
      }
      return getAssets;
    }(),
    getTipAddress: function () {
      var _getTipAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(chainId, cb) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = getMixinContext().platform;
                _context2.next = _context2.t0 === 'iOS' ? 3 : _context2.t0 === 'Android' ? 8 : _context2.t0 === 'Desktop' ? 8 : 13;
                break;
              case 3:
                if (!(window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.getTipAddress)) {
                  _context2.next = 7;
                  break;
                }
                window.tipAddressCallbackFunction = cb;
                _context2.next = 7;
                return window.webkit.messageHandlers.getTipAddress.postMessage([chainId, 'tipAddressCallbackFunction']);
              case 7:
                return _context2.abrupt("break", 14);
              case 8:
                if (!(window.MixinContext && typeof window.MixinContext.getTipAddress === 'function')) {
                  _context2.next = 12;
                  break;
                }
                window.tipAddressCallbackFunction = cb;
                _context2.next = 12;
                return window.MixinContext.getTipAddress(chainId, 'tipAddressCallbackFunction');
              case 12:
                return _context2.abrupt("break", 14);
              case 13:
                return _context2.abrupt("break", 14);
              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      function getTipAddress(_x3, _x4) {
        return _getTipAddress.apply(this, arguments);
      }
      return getTipAddress;
    }(),
    tipSign: function () {
      var _tipSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(chainId, msg, cb) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.t0 = getMixinContext().platform;
                _context3.next = _context3.t0 === 'iOS' ? 3 : _context3.t0 === 'Android' ? 8 : _context3.t0 === 'Desktop' ? 8 : 13;
                break;
              case 3:
                if (!(window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.tipSign)) {
                  _context3.next = 7;
                  break;
                }
                window.tipSignCallbackFunction = cb;
                _context3.next = 7;
                return window.webkit.messageHandlers.tipSign.postMessage([chainId, msg, 'tipSignCallbackFunction']);
              case 7:
                return _context3.abrupt("break", 14);
              case 8:
                if (!(window.MixinContext && typeof window.MixinContext.tipSign === 'function')) {
                  _context3.next = 12;
                  break;
                }
                window.tipSignCallbackFunction = cb;
                _context3.next = 12;
                return window.MixinContext.tipSign(chainId, msg, 'tipSignCallbackFunction');
              case 12:
                return _context3.abrupt("break", 14);
              case 13:
                return _context3.abrupt("break", 14);
              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function tipSign(_x5, _x6, _x7) {
        return _tipSign.apply(this, arguments);
      }
      return tipSign;
    }()
  };
};

var MixinAssetID = '43d61dcd-e413-450d-80b8-101d5e903357';
var MixinCashier = '674d6776-d600-4346-af46-58e77d8df185';

export { AddressClient, AppClient, AssetClient, AttachmentClient, BlazeClient, CircleClient, CodeClient, CollectibleClient, ConversationClient, Decoder, DefaultChain, DefaultClass, DefaultNftAssetId, Encoder, ExternalClient, GroupMembers, GroupThreshold, MainAddressPrefix, MessageClient, MintMinimumCost, MixAddressPrefix, MixAddressVersion, MixinApi, MixinAssetID, MixinCashier, MultisigClient, NetworkClient, OAuthClient, OutputTypeScript, OutputTypeWithdrawalSubmit, PaymentClient, PinClient, ResponseError, SafeClient, TIPBodyForSequencerRegister, TransferClient, TxVersion, TxVersionHashSignature, UserClient, UtxoClient, WebViewApi, base64RawURLDecode, base64RawURLEncode, bigNumberToBytes, blake3Hash, buildClient, buildCollectibleMemo, buildMixAddress, buildMixinOneSafePaymentUri, buildMultiSigsTransaction, buildNfoTransferRequest, buildSafeTransaction, buildSafeTransactionRecipient, buildTokenId, bytesToInterger, createAxiosClient, createRequestClient, decodeMessage, decodeNfoMemo, decodeSafeTransaction, deriveGhostPublicKey, edwards25519, encodeSafeTransaction, encodeScript, encodeTx, formatUnits, getCreateAddressTipBody, getED25519KeyPair, getMainnetAddressFromPublic, getMainnetAddressGhostKey, getNanoTime, getPublicFromMainnetAddress, getRemoveAddressTipBody, getTipPinUpdateMsg, getTotalBalanceFromOutputs, getUnspentOutputsForRecipients, getUuid, getVerifyPinTipBody, hashMembers, integerToBytes, magic, mixinRequest, newHash, parseMixAddress, parseUnits, putUvarInt, sendRaw, sha256Hash, sha512Hash, sharedEd25519Key, signAccessToken, signAuthenticationToken, signEd25519PIN, signOauthAccessToken, signSafeRegistration, signSafeTransaction, signTipBody, sleep, tipBody, uniqueConversationID };
//# sourceMappingURL=mixin-node-sdk.esm.js.map
