/// <reference types="ws" />
/// <reference types="node" />
import type { AxiosInstance } from 'axios';
import type Keystore from './types/keystore';
import type { HTTPConfig, RequestClient } from './types';
declare const KeystoreClient: (axiosInstance: AxiosInstance, keystore: Keystore | undefined, config: HTTPConfig) => {
    address: {
        fetch: (addressID: string) => Promise<import("./types").AddressResponse>;
        fetchList: (assetID: string) => Promise<import("./types").AddressResponse[]>;
        create: (pin: string, params: import("./types").AddressRequest) => Promise<import("./types").AddressResponse>;
        delete: (pin: string, addressID: string) => Promise<any>;
    };
    app: {
        fetch: (appID: string) => Promise<import("./types").AppResponse>;
        fetchList: () => Promise<import("./types").AppResponse[]>;
        properties: () => Promise<import("./types").AppPropertyResponse>;
        favorites: (userID: string) => Promise<import("./types").AppResponse[]>;
        create: (params: import("./types").AppRequest) => Promise<import("./types").AppResponse>;
        update: (appID: string, params: import("./types").AppRequest) => Promise<import("./types").AppResponse>;
        updateSecret: (appID: string) => Promise<import("./types").AppSecretResponse>;
        updateSafeSession: (appID: string, data: import("./types").AppSafeSessionRequest) => Promise<import("./types").AppSessionResponse>;
        registerSafe: (appID: string, data: import("./types").AppSafeRegistrationRequest) => Promise<import("./types").AppRegistrationResponse>;
        favorite: (appID: string) => Promise<import("./types").AppResponse[]>;
        unfavorite: (appID: string) => Promise<any>;
    };
    asset: {
        fetch: (assetID: string) => Promise<import("./types").AssetResponse>;
        fetchList: () => Promise<import("./types").AssetResponse[]>;
        snapshots: (assetID: string) => Promise<import("./types").SnapshotResponse[]>;
    };
    blaze: {
        loop: (h: import("./types").BlazeHandler) => void;
        stopLoop: () => void;
        getWebSocket: () => import("ws") | undefined;
    };
    attachment: {
        fetch: (attachmentID: string) => Promise<import("./types").AttachmentResponse>;
        create: () => Promise<import("./types").AttachmentResponse>;
        upload: (file: File) => Promise<{
            view_url: string;
            attachment_id: string;
        }>;
    };
    circle: {
        fetch: (circleID: string) => Promise<import("./types").CircleResponse>;
        fetchList: () => Promise<import("./types").CircleResponse[]>;
        conversations: (circleID: string, params: import("./types").CircleRequest) => Promise<import("./types").CircleConversationResponse[]>;
        create: (name: string) => Promise<import("./types").CircleResponse>;
        update: (circleID: string, name: string) => Promise<import("./types").CircleResponse>;
        delete: (circleID: string) => Promise<any>;
        addUser: (userID: string, circleID: string) => Promise<import("./types").CircleResponse[]>;
        removeUser: (userID: string, circleID: string) => Promise<import("./types").CircleResponse[]>;
        addConversation: (conversationID: string, circleID: string) => Promise<import("./types").CircleResponse[]>;
        removeConversation: (conversation_id: string, circleID: string) => Promise<import("./types").CircleResponse[]>;
    };
    code: {
        fetch: (codeID: string) => Promise<import("./types").CodeResponse>;
    };
    collection: {
        fetch: (tokenID: string) => Promise<import("./types").CollectibleResponse>;
        fetchCollection: (collectionID: string) => Promise<import("./types").CollectionResponse>;
        outputs: (params: import("./types").CollectibleOutputsRequest) => Promise<import("./types").CollectibleOutputsResponse[]>;
        request: (action: import("./types").MultisigInitAction, raw: string) => Promise<import("./types").CollectibleTransactionResponse>;
        transfer: (action: import("./types").MultisigInitAction, raw: string) => Promise<import("./types").CollectibleTransactionResponse>;
        sign: (pin: string, requestID: string) => Promise<import("./types").CollectibleTransactionResponse>;
        cancel: (pin: string, requestID: string) => Promise<import("./types").CollectibleTransactionResponse>;
        unlock: (pin: string, requestID: string) => Promise<import("./types").CollectibleTransactionResponse>;
    };
    conversation: {
        fetch: (conversationID: string) => Promise<import("./types").ConversationResponse>;
        create: (params: import("./types").ConversationRequest) => Promise<import("./types").ConversationResponse>;
        createContact: (userID: string) => Promise<import("./types").ConversationResponse>;
        createGroup: (conversationID: string, name: string, participant: import("./types").ParticipantRequest[]) => Promise<import("./types").ConversationResponse>;
        joinGroup: (codeID: string) => Promise<import("./types").ConversationResponse>;
        exitGroup: (conversationID: string) => Promise<import("./types").ConversationResponse>;
        updateParticipants: (conversationID: string, action: import("./types").ConversationAction, participant: import("./types").ParticipantRequest[]) => Promise<import("./types").ConversationResponse>;
        addParticipants: (conversationID: string, userIDs: string[]) => Promise<import("./types").ConversationResponse>;
        removeParticipants: (conversationID: string, userIDs: string[]) => Promise<import("./types").ConversationResponse>;
        setAdmin: (conversationID: string, userIDs: string[]) => Promise<import("./types").ConversationResponse>;
        revokeAdmin: (conversationID: string, userIDs: string[]) => Promise<import("./types").ConversationResponse>;
        resetGroupCode: (conversationID: string) => Promise<import("./types").ConversationResponse>;
        updateGroupInfo: (conversationID: string, params: Pick<import("./types").ConversationRequest, "name" | "announcement">) => Promise<import("./types").ConversationResponse>;
        mute: (conversationID: string, duration: number) => Promise<import("./types").ConversationResponse>;
        unmute: (conversationID: string) => Promise<import("./types").ConversationResponse>;
        disappearDuration: (conversationID: string, duration: number) => Promise<import("./types").ConversationResponse>;
    };
    external: {
        deposits: (params: import("./types").DepositRequest) => Promise<import("./types").ExternalTransactionResponse[]>;
        checkAddress: (params: import("./types").CheckAddressRequest) => Promise<import("./types").CheckAddressResponse>;
        exchangeRates: () => Promise<import("./types").ExchangeRateResponse[]>;
        proxy: (params: import("./types").ProxyRequest) => Promise<any>;
    };
    message: {
        sendAcknowledgement: (message: import("./types").AcknowledgementRequest) => Promise<import("./types").AcknowledgementResponse[]>;
        sendAcknowledges: (messages: import("./types").AcknowledgementRequest[]) => Promise<import("./types").AcknowledgementResponse[]>;
        sendOne: (message: import("./types").MessageRequest) => Promise<any>;
        sendBatch: (messages: import("./types").MessageRequest[]) => Promise<any>;
        sendMsg: (recipientID: string, category: import("./types").MessageCategory, data: any) => Promise<import("./types").MessageRequest>;
        sendText: (userID: string, text: string) => Promise<import("./types").MessageRequest>;
        sendSticker: (userID: string, sticker: import("./types").StickerMessageRequest) => Promise<import("./types").MessageRequest>;
        sendImage: (userID: string, image: import("./types").ImageMessageRequest) => Promise<import("./types").MessageRequest>;
        sendAudio: (userID: string, audio: import("./types").AudioMessageRequest) => Promise<import("./types").MessageRequest>;
        sendVideo: (userID: string, video: import("./types").VideoMessageRequest) => Promise<import("./types").MessageRequest>;
        sendContact: (userID: string, contact: import("./types").ContactMessageRequest) => Promise<import("./types").MessageRequest>;
        sendAppCard: (userID: string, appCard: import("./types").AppCardMessageRequest) => Promise<import("./types").MessageRequest>;
        sendFile: (userID: string, file: import("./types").FileMessageRequest) => Promise<import("./types").MessageRequest>;
        sendLive: (userID: string, live: import("./types").LiveMessageRequest) => Promise<import("./types").MessageRequest>;
        sendLocation: (userID: string, location: import("./types").LocationMessageRequest) => Promise<import("./types").MessageRequest>;
        sendPost: (userID: string, text: string) => Promise<import("./types").MessageRequest>;
        sendAppButton: (userID: string, appButton: import("./types").AppButtonMessageRequest[]) => Promise<import("./types").MessageRequest>;
        sendTransfer: (userID: string, transfer: import("./types").TransferMessageRequest) => Promise<import("./types").MessageRequest>;
        sendRecall: (userID: string, message: import("./types").RecallMessageRequest) => Promise<import("./types").MessageRequest>;
    };
    multisig: {
        outputs: (params: import("./types").MultisigRequest) => Promise<import("./types").MultisigUtxoResponse[]>;
        create: (action: import("./types").MultisigInitAction, raw: string) => Promise<import("./types").MultisigRequestResponse>;
        sign: (pin: string, requestID: string) => Promise<import("./types").MultisigRequestResponse>;
        unlock: (pin: string, requestID: string) => Promise<import("./types").MultisigRequestResponse>;
        cancel: (pin: string, requestID: string) => Promise<import("./types").MultisigRequestResponse>;
        createSafeMultisigs: (params: import("./types").TransactionRequest[]) => Promise<import("./types").SafeMultisigsResponse[]>;
        fetchSafeMultisigs: (id: string) => Promise<import("./types").SafeMultisigsResponse>;
        signSafeMultisigs: (id: string, raw: string) => Promise<import("./types").SafeMultisigsResponse>;
        unlockSafeMultisigs: (id: string) => Promise<import("./types").SafeMultisigsResponse>;
    };
    network: {
        info: () => Promise<import("./types").NetworkInfoResponse>;
        chains: () => Promise<import("./types").NetworkChainResponse[]>;
        fetchChain: (chainID: string) => Promise<import("./types").NetworkChainResponse>;
        fetchAsset: (assetID: string) => Promise<import("./types").NetworkAssetResponse>;
        topAssets: (kind?: string) => Promise<import("./types").AssetResponse[]>;
        searchAssets: (keyword: string, kind?: string) => Promise<import("./types").AssetResponse[]>;
        historicalPrice: (assetID: string, offset?: string | undefined) => Promise<import("./types").NetworkPriceResponse>;
        snapshot: (snapshotID: string) => Promise<import("./types").NetworkSnapshotResponse>;
        snapshots: (inputParams: import("./types").NetworkSnapshotRequest) => Promise<import("./types").NetworkSnapshotResponse[]>;
    };
    oauth: {
        getToken: (data: import("./types").AccessTokenRequest) => Promise<import("./types").AccessTokenResponse>;
        authorize: (data: import("./types").AuthorizeRequest) => Promise<import("./types").AuthorizationResponse>;
        authorizations: (appId?: string | undefined) => Promise<import("./types").AuthorizationResponse[]>;
        revokeAuthorize: (clientId: string) => Promise<void>;
    };
    payment: {
        request: (params: import("./types").TransferRequest | import("./types").RawTransactionRequest) => Promise<import("./types").PaymentRequestResponse>;
        payment: (params: import("./types").TransferRequest | import("./types").RawTransactionRequest) => Promise<import("./types").PaymentRequestResponse>;
    };
    pin: {
        verify: (pin: string) => Promise<import("./types").AuthenticationUserResponse>;
        verifyTipPin: (pin: string) => Promise<import("./types").AuthenticationUserResponse>;
        update: (firstPin: string, secondPin?: string) => Promise<import("./types").AuthenticationUserResponse>;
        updateTipPin: (firstPin: string, secondPin: string, counter: number) => Promise<import("./types").AuthenticationUserResponse>;
    };
    safe: {
        register: (user_id: string, tipPin: string, priv: Buffer) => Promise<import("./types").AuthenticationUserResponse>;
        checkRegisteration: () => Promise<import("./types").AuthenticationUserResponse>;
        assets: () => Promise<import("./types").SafeAsset[]>;
        fetchAsset: (id: string) => Promise<import("./types").SafeAsset>;
        fetchAssets: (assetIds: string[]) => Promise<import("./types").SafeAsset[]>;
        depositEntries: (data: import("./types").SafeDepositEntriesRequest) => Promise<import("./types").SafeDepositEntryResponse[]>;
        createDeposit: (chain_id: string) => Promise<import("./types").SafeDepositEntryResponse[]>;
        pendingDeposits: (params: import("./types").SafePendingDepositRequest) => Promise<import("./types").SafePendingDepositResponse[]>;
        fetchSafeSnapshots: (data: import("./types").SafeSnapshotsRequest) => Promise<import("./types").SafeSnapshot[]>;
        fetchSafeSnapshot: (id: string) => Promise<import("./types").SafeSnapshot>;
    };
    transfer: {
        fetch: (traceID: string) => Promise<import("./types").SnapshotResponse>;
        snapshot: (snapshotID: string) => Promise<import("./types").SnapshotResponse>;
        snapshots: (params: import("./types").SnapshotRequest) => Promise<import("./types").SnapshotResponse[]>;
        toUser: (pin: string, params: import("./types").TransferRequest) => Promise<import("./types").SnapshotResponse>;
        toAddress: (pin: string, params: import("./types").RawTransactionRequest) => Promise<import("./types").SnapshotResponse>;
        outputs: (input: import("./types").GhostInputRequest[]) => Promise<import("./types").GhostKeysResponse[]>;
    };
    user: {
        profile: () => Promise<import("./types").AuthenticationUserResponse>;
        friends: () => Promise<import("./types").UserResponse[]>;
        blockings: () => Promise<import("./types").UserResponse[]>;
        rotateCode: () => Promise<import("./types").AuthenticationUserResponse>;
        search: (identityNumberOrPhone: string) => Promise<import("./types").UserResponse>;
        fetch: (id: string) => Promise<import("./types").UserResponse>;
        fetchList: (userIDs: string[]) => Promise<import("./types").UserResponse[]>;
        createBareUser: (fullName: string, sessionSecret: string) => Promise<import("./types").UserResponse>;
        update: (fullName: string, avatarBase64: string) => Promise<import("./types").UserResponse>;
        updatePreferences: (params: import("../types").AtLeastOne<import("./types").PreferenceRequest, {
            receive_message_source: Pick<import("./types").PreferenceRequest, "receive_message_source">;
            accept_conversation_source: Pick<import("./types").PreferenceRequest, "accept_conversation_source">;
            accept_search_source: Pick<import("./types").PreferenceRequest, "accept_search_source">;
            fiat_currency: Pick<import("./types").PreferenceRequest, "fiat_currency">;
            transfer_notification_threshold?: Pick<import("./types").PreferenceRequest, "transfer_notification_threshold"> | undefined;
            transfer_confirmation_threshold?: Pick<import("./types").PreferenceRequest, "transfer_confirmation_threshold"> | undefined;
        }>) => Promise<import("./types").AuthenticationUserResponse>;
        updateRelationships: (relationship: import("./types").RelationshipRequest | import("./types").RelationshipAddRequest) => Promise<import("./types").UserResponse>;
        logs: (params: import("./types").LogRequest) => Promise<import("./types").LogResponse[]>;
    };
    utxo: {
        outputs: (params: import("./types").OutputsRequest) => Promise<import("./types").UtxoOutput[]>;
        safeOutputs: (params: import("./types").SafeOutputsRequest) => Promise<import("./types").SafeUtxoOutput[]>;
        safeAssetBalance: (params: import("./types").SafeBalanceRequest) => Promise<string>;
        fetchSafeOutputs: (params: import("./types").OutputFetchRequest) => Promise<import("./types").UtxoOutput[]>;
        fetchTransaction: (transactionId: string) => Promise<import("./types").SequencerTransactionRequest>;
        verifyTransaction: (params: import("./types").TransactionRequest[]) => Promise<import("./types").SequencerTransactionRequest[]>;
        sendTransactions: (params: import("./types").TransactionRequest[]) => Promise<import("./types").SequencerTransactionRequest[]>;
        ghostKey: (params: import("./types").GhostKeyRequest[]) => Promise<import("./types").GhostKey[]>;
    };
};
export declare type KeystoreClientReturnType = ReturnType<typeof KeystoreClient>;
export declare function MixinApi(config?: HTTPConfig): KeystoreClientReturnType & RequestClient;
export {};
